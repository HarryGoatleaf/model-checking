---
title: "Model Checking"
format:
  html:
    theme: darkly
    toc: true
    toc-depth: 3
    self-contained: false
    code-overflow: "wrap"
    code-line-numbers: true
---

\newcommand{\w}{\omega}
\newcommand{\phi}{\varphi}

## Transition Systems

Intuition

Program | Automaton
:------:|:--------:
state | nodes
stepwise behaviour | transition
possible preconditions | init states
communication | actions 
atomic propositions | state properties

::: {#def-transition-system}
### Transition System

Formaly a transition system $T$ is a tuple $(S, Act, \rightarrow, S_0, AP, L)$
where

* $S$ countable set of **states**
* $Act$ set of **actions**
* $\rightarrow \ \subseteq S \times Act \times S$ a **transition relation**
* $S_0 \subseteq S$ a set of **initial states**
* set of **atomic propositions** $AP$ with
* a **labeling function** $L : S \rightarrow 2^{AP}$ that assigns propositions to each state
:::

::: {.callout-note}
### Differences to finite automata
* Possibly infinity state space.
* No accepting states.
* Multiple initial states.
:::

Execution Fragment
: An execution fragment of a transition system is an alternating sequence
  <!-- infinite??? -->
  sequence of states and actions:
$$ \rho = s_0 \alpha_1 s_1 \alpha_2 \ ... \text{ such that } s_i \xrightarrow{\alpha_{i+1}} s_{i+1}$$

Maximal
: An execution fragment is maximal iff. it is infinite or it is ending in a terminal state.

Initial
: An execution fragment is initial iff. it starts in an initial state.

Execution
: An execution is an initial & maximal execution fragment. (corresponds to run on automata)

Path
: Let $s_0 \alpha_1 s_1 ...$ be an execution, then $s_0s_1 ...$ is a path.
  In other words a path is the sequence of states of an execution.

Reachable fragment
: $Reach(T)$ set of states that appear on some path.

Trace
: Let $s_0s_1...$ be a path, then $L(s_0)L(s_1)...$ is a trace.
  In other words a trace is the sequence of atomic propositions that hold along a path.

### Program Graph

Program graphs are an abstraction of (imperative) programs.

::: {#def-program-graph}
#### Program Graph

A program graph is a tuple
$$(Loc, Act, Effect, \hookrightarrow, Loc_0, g_0)$$

where

* $Loc$ is a set of **locations** (roughtly corresponds to code lines)
* $Act$ is a set of **actions**
* $Effect: Act \times Eval(Var) \rightarrow Eval(Var)$ models the **effect** of actions
* $\hookrightarrow \subseteq Loc \times Cond(Var) \times Act \times Loc$ is the **edge relation**
* $g_0 \in Cond(Var)$ is the **initial condition**
:::

### Translating Program Graphs to Transition Systems

Let $PG = (Loc, Act, Effect, \hookrightarrow, Loc_0, g_0)$ be a program graph.
Then this can be modeled by the transition system $(S, Act, \rightarrow I, AP, L)$ where

* $S = Loc \times Eval(Var)$
* $\rightarrow \subseteq S \times Act \times S$ can be deduced by the following rule
  $$\frac{l \xhookrightarrow{g:\alpha} l' \land \eta \models g} {\langle l, \eta \rangle \xrightarrow{\alpha} \langle l', Effect(\alpha, \eta) \rangle}$$
* $I = \{ \langle l, \eta \rangle | l \in Loc_0, \eta \models g_0 \}$
* $L( \langle l, \eta \rangle) = \{l\} \cup \{g \in Cond(Var) | \eta \models g \}$

### Interleaving

We can model multi-threaded execution **without shared variables** by interleaving the transition systems.

::: {#def-interleaving-trans}
#### Interleaving transition systems

Let $TS_1, TS_2$ be two transition systems.
Then
$$TS_1 \ ||| \ TS_2 := (S_1 \times S_2, Act_1 \uplus Act_2, \rightarrow, I_1 \times I_2, AP_1 \uplus AP_2, L)$$

* $L(\langle s_1, s_2 \rangle) = L_1(s_1) \cup L_2(s_2)$
* And $\rightarrow$ can be deduced by the following rule:
  $$ 
  \frac{s_1 \xrightarrow{\alpha} s_1'} 
  {\langle s_1, \textcolor{gray}{s_2} \rangle \xrightarrow{\alpha} \langle s_1', \textcolor{gray}{s_2}\rangle}
  \text{ and }
  \frac{s_2 \xrightarrow{\alpha} s_2'} 
  {\langle \textcolor{gray}{s_1}, s_2 \rangle \xrightarrow{\alpha} \langle \textcolor{gray}{s_1}, s_2'\rangle}
  $$
:::

We can model multi-threaded execution **with shared variables** by interleaving the program graphs.

::: {#def-interleaving-prog}
#### Interleaving program graphs

Let $PG_1, PG_2$ be two program graphs over the **same variables**. Then
$PG_1 \ ||| \ PG_2 := (Loc_1 \times Loc_2, Act_1 \uplus Act_2, Effect, \hookrightarrow,$ \
$Loc_{0,1} \uplus Loc_{0,2}, g_{0, 1} \land g_{0, 2})$

* $Effect(\alpha, \eta) = Effect_i(\alpha, \eta)$ for $\alpha \in Act_i$.
* And $\hookrightarrow$ can be deduced by the following rule:
  $$ 
  \frac{l_1 \xhookrightarrow{g:\alpha} l_1'} 
  {\langle l_1, \textcolor{gray}{l_2} \rangle \xhookrightarrow{g:\alpha} \langle l_1', \textcolor{gray}{l_2}\rangle}
  \text{ and }
  \frac{l_2 \xhookrightarrow{g:\alpha} l_2'} 
  {\langle \textcolor{gray}{l_1}, l_2 \rangle \xhookrightarrow{g:\alpha} \langle \textcolor{gray}{l_1}, l_2'\rangle}
  $$
:::

::: {.callout-important}
In general it **does not hold** that $TS(PG_1) \ ||| \ TS(PG_1) = TS(PG_1 \ ||| \ PG_2)$
:::

::: {.callout-warning}
#### State Explosion Problem
State space grows **exponentially** with number of **threads** and **variables**.
:::

## Linear Time Properties

::: {#def-linear-time-property}
### Linear Time Property
A **linear-time property** over some atomic propositions $AP$ is a subset of 
$\left(2^{AP}\right)^\omega$.

A transitionsystem $TS$ satisfies a LT property $P$

$$TS \models P \text{ iff. } Traces(TS) \subseteq P$$
:::

Invariant
: LT property of the form $A^\w$ for some $A \subseteq 2^{AP}$ i.e.
  "some property holds forever"

Persistance Property
: LT property of the form ${(2^{AP})}^* A^\w$ i.e.
  "some property eventually holds forever"

Closure
: For a LT property $P$ the closure contains all traces $t$ such that
  for each prefix of $t$ a trace in $P$ has the same prefix.

<!-- example -->

::: {#def-safety-property}
### Safety Property
A LT property $S$ over AP is a **safety property** if for all
$\sigma \in (2^{AP})^\omega \setminus S$
we can find a "bad prefix" $\hat{\sigma}$
such that no word in $S$ has prefix $\hat{\sigma}$

$$ cl(S) = S $$
:::

Trace Equivalence != Finite Trace Equivalence
<!-- TODO: note -->

::: {#def-liveness-property}
### Liveness Property
LT property $L$ over $AP$ is a **liveness property** iff.

$$pref(L) = {2^{AP}}^*$$
:::

::: {#def-w-regular-expression}
#### $\w$-regular Expression
An $\w$-regular expression has the form:

$$G = E_1.F_1^\w + ... + E_n.F_n^\w$$

where $E_i, F_i$ are regular expressions.

If a LT property can be defined by an $\w$-regular expression
we call it $\w$-*regular property*
:::

::: {#thm-trace-inclusion-lt-properties}
Let $TS, TS'$ be transition systems without terminal states:

\begin{align}
Traces(TS) \quad & \subseteq \quad Traces(TS') \\
& \text{iff.} \\
TS' \models P \quad & \Rightarrow \quad TS \models P 
, \text{ for all LT-props } P\\
\end{align}

For **safety property** we know that:

\begin{align}
Traces_{fin}(TS) \quad & \subseteq \quad Traces_{fin}(TS') \\
& \text{iff.} \\
TS' \models P \quad & \Rightarrow \quad TS \models P 
, \text{ for all \textbf{safety} props } P\\
\end{align}

:::

::: {#cor-trace-equivalence}
$Traces(TS) = Traces(TS')$ iff. $TS$ and $TS'$ satisfy the same LT properties and analogously \
$Traces_{fin}(TS) = Traces_{fin}(TS')$ iff. $TS$ and $TS'$
satisfy the same safety properties.
:::

::: {#lem-finite-image-trace}
If $TS'$ is image finite (ger: endlich verzweigt) we know that:

$$Traces(TS) \subseteq Traces(TS') \Leftrightarrow
  Traces_{fin}(TS) \subseteq Traces_{fin}(TS')$$
:::

::: {#def-synchronous-product}
#### Synchronous Product
Let:

* $TS := (S, Act, \rightharpoonup, I, AP, L)$ without terminal states
* $A := (Q, \Sigma, \rightharpoondown, Q_0, F)$ and NFA
  * $\Sigma = 2^{AP}$ i.e. defines trace prefixes
  * $Q_0 \cap F = \emptyset$

Let $TS$ be a transition system without terminal states and \
$A$ an NFA with $\Sigma = 2^{AP}$ and $Q_0 \cap F = \emptyset$

Then:

$$TS \otimes A := (S', Act, \rightarrow, I', AP', L')$$

* $S' = S \times Q$
* $AP' = Q$
* $L'( \langle s, q \rangle) = \{q\}$
* $\rightarrow$ can be deduced by:

$$\frac{s \xrightharpoonup{\alpha} \textcolor{orange}{t} \land q \xrightharpoondown{L(\textcolor{orange}{t})} p} {\langle {s}, {q} \rangle \xrightarrow{\alpha} \langle {\textcolor{orange}{t}}, {p} \rangle}$$

* $I' =  \{ \langle s_0, q \rangle | s_0 \in I \land \exists q_0 \in Q_0 . q_0 \xrightharpoondown{L(s_0)} q \}$
:::

::: {#thm-verifying-regular-safety-properties}
Let $TS$ be some transition system. $E_{safe}$ a safety property
and $A$ an NFA that recognizes the bad prefixes of $E_{safe}$.
Then:

$$TS \models E_{safe} \Leftrightarrow TS \otimes A \text{ has no reachable accepting states}$$
:::

::: {#def-buechi-automaton}
#### Büchi automaton

A *nondeterministic Büchi automaton* (NBA) is a tuple
$(Q, \Sigma, \delta, Q_0, F)$ where:

* $Q$ is a finite set of **states**
* $\Sigma$ is a finite **alphabet**
* $\delta: Q \times \Sigma \rightarrow 2^Q$ a **transition function**
* $Q_0 \subseteq Q$ a set of **initial states**
* $F \subseteq Q$ set of **accepting states**

**Acceptance condition**: There exists a run that **infinitely often** visits an
accepting state.
:::

Property       | NFA                        | NBA
---------------|----------------------------|----------------------------
Recognizes:    | regular languages          | $\w$-regular languages
Closure $\cup$ | union operator             | union operator
Closure $\cap$ | product construction       | GNBA product
Closure $\neg$ | build DFA and complement F | complex procedure
Determinism    | NFA = DFA                  | DBA $\subsetneq$ NBA

: NFA vs. NBA

<!-- lecture 6 start -->
## Verifying $\w$-regular Safety Properties

Idea
: Define Büchi automaton $\mathfrak{A}$ for _bad behaviour_ $E$.
  The atomic property $F$ labels all _accepting_ states of $\mathfrak{A}$. Check if 
  $$T \otimes \mathfrak{A} \models \text{ eventually forever } \neg F$$
  Here $\otimes$ is defined like in @def-synchronous-product.

::: {#thm-persistence-prop-check}
### Persistence Property Check

Let $P$ be some _persistence property_ of the form "$\text{eventually forever } \phi$".
Then it equivalent:

1. $\Leftrightarrow TS \models P$
2. $\Leftrightarrow \exists s. (s \in \text{Reach}(TS) \land s \not \models \phi \land s \text{ is on cycle})$
3. $\Leftrightarrow \exists C. (C \text{ is reachable } \land C \text{ is a SCC} \land C \cap \{ s \in S | s \not \models \phi \} \neq \emptyset)$

Strongly Connected Component ([SCC](https://en.wikipedia.org/wiki/Strongly_connected_component))
: Set of **states** $C$ such that for all $x, y \in C$: $x$ is _reachable_ from $y$.

### SCC Method

* compute all _inclusion maximal_ SCCs
* remove unreachable SCCs
* check for a state $s \models \neg \phi$

::: {.callout-caution}
#### Not practical
:::

### Cycle Method

**Naïve way:** $\Theta(|V| \cdot |E|)$

* use [DFS](https://en.wikipedia.org/wiki/Depth-first_search) to find states $s \models \neg \phi$
* use _second_ DFS to check wether cycle is reachable from itself (i.e. belongs to cycle)

**Imprövement:** $\Theta(|V| + |E|)$

* use outer DFS to find states $s \models \neg \phi$
* use inner DFS to check wether cycle is reachable from itself **while avoiding states visited in a previous inner DFS**, i.e. maintain **one** `visited` set across all executions of the inner DFS.

:::


<!-- lecture 6 end -->

## Linear Temporal Logic (LTL)
<!-- macros -->
\newcommand{\true}{\texttt{true}}
\newcommand{\false}{\texttt{false}}
<!-- tomporal -->
\newcommand{\U}{\textbf{U}}
\newcommand{\R}{\textbf{R}}
\newcommand{\W}{\textbf{W}}
\newcommand{\M}{\textbf{M}}
<!-- modal -->
\newcommand{\box}{\square}
\newcommand{\dia}{\diamond}
\newcommand{\cir}{\bigcirc}
\newcommand{\next}{\bigcirc}

For a set of atomic propositions $AP$ we give the BNF grammar for LTL:

* $\phi = a \text{ for } a \in AP$
* $\phi = \true | \phi \lor \phi | \neg \phi$
* $\phi = \cir \phi$ "next"
* $\phi = \phi \U \phi$ "until"

**Derived Operators**:

* the usual: \
  $\false, \lor, \leftarrow, \rightarrow, \leftrightarrow, \otimes$
* modal operators:
  * "eventually" $\dia \phi := \true \U \phi$ 
  * "always" $\box \phi := \neg \dia \neg \phi$
* temporal operators:
  * "release" $\phi \R \psi := \neg (\neg \phi \U \psi)$
  * "weak until" 
    $\phi \W \psi := (\phi \U \psi) \lor \box \phi$ 
  * "strong release"
  $\phi \M \psi := (\phi \R \psi) \land \dia \phi$
  
**Equivalences**:

**Dualities**:

* $\neg \box \phi \equiv \dia \neg \phi$
* $\neg \cir \phi \equiv \cir \neg \phi$
* $\neg (\phi \U \psi) \equiv \neg \phi \R \neg \psi$
* $\neg (\phi \U \psi) \equiv (\phi \land \neg \psi) \R (\neg \phi \land \neg \psi)$
* $\neg (\phi \W \psi) \equiv \neg \phi \M \neg \psi$
* $\neg (\phi \W \psi) \equiv (\phi \land \neg \psi) \U (\neg \phi \land \neg \psi)$

**Absorbtion**:

* $\box \box \phi \equiv \box \phi$
* $\dia \dia \phi \equiv \dia \phi$
* $\box \dia \box \phi \equiv \dia \box \phi$
* $\dia \box \dia \phi \equiv \box \dia \phi$
* $\phi \U (\phi \U \psi) \equiv \phi \U \psi$
* $(\phi \U \psi) \U \psi \equiv \phi \U \psi$

**Distribution**:

* $\next (\phi \U \psi) \equiv (\next \phi \U \next \psi)$
* $\dia (\phi \lor \psi) \equiv \dia \phi \lor \dia \psi$
* $\box (\phi \land \psi) \equiv \box \phi \land \box \psi$

::: {.callout-caution}

* $\dia (\phi \land \psi) \not \equiv \dia \phi \land \dia \psi$
* $\box (\phi \lor \psi) \not \equiv \box \phi \lor \box \psi$

:::

**Expansion**:

* $\dia \phi \equiv \phi \lor \next \dia \phi$
* $\box \phi \equiv \phi \land \next \box \phi$
* $\phi \U \psi \equiv \psi \lor (\phi \land \next (\phi \U \psi))$

<!-- TODO: formal semantics -->
<!-- TODO: examples -->

## Model checking of LTL

::: {#def-gnba}
### Generalized Büchi Automata

A *Generalized Non-deterministic Büchi Automaton* (GNBA) is a tuple
$(Q, \Sigma, \delta, Q_0, \mathfrak{F})$ where

$$\mathfrak{F} = \{ F_1, ..., F_k \} \text{ with } F_i \subseteq Q$$

A run $r_1r_2...$ on this automaton is **accepting** if:
$$\forall F_j. \exists^\infty i. r_i \in F_j$$
:::

::: {.callout-note}
For NBA $A$ the NBA for $\bar{A}$ has $c^{n^2}$ states in worst case.

Solution: use $A_{\neg \phi} \equiv \bar{A}$
:::

expand $\sigma = A_1A_2...$ to $B_1B_2...$
where 
$B_i = A_i \cup 
\{ \psi | \psi \models A_i, \psi \text{ subformula of } \phi\}$

Closure of LTL formula
: all subformulas and their negations

::: {#def-elementary-sets}
### Elementary sets

Let

1. maximaly consistent:
  * $\phi \land \psi \in B \Leftrightarrow \phi \in B \land \psi \in B$
  * $\phi \notin B \Leftrightarrow \neg \phi \in B$
  * $true \in cl(\phi) \Rightarrow true \in B$
2. locally consistent: for $\phi U \psi \in cl(\sigma)$
  * $\psi \in B \Rightarrow \phi U \psi \in B$
  * $\phi U \psi \in B \land \psi \notin B \Rightarrow \phi \in B$
:::

* $\Sigma = 2^{AP}$
* $Q := $ elementary sets
* $Q_0$ all sets with $\phi$
* $\delta := $
  * $\circ \phi \in B \Leftrightarrow \phi \in B'$
  * (expansion law)
    $\phi U \psi \in B \Leftrightarrow 
    (\psi \in B \lor (\phi \in B \land \phi U \psi \in B'\))

::: {.callout-note collapse=true}
### Size of NBA can be exponential

The **worst-case** runtime for constructing an NBA that recognizes a formula is **exponential**.
This is because the constructed NBA can be exponentially large.
For example for $n \in \mathbb{N}$ consider 
$$\phi_n := \bigwedge_{a \in AP} \bigwedge_{0 \leq i < n} (\next^i a \leftrightarrow \next^{n+i} a)$$

Intuitively we can see that after reading the first $n$ characters the automaton has to remember
for all $0 \leq i < 0$ and every $a \in AP$ if $a$ holds at position $i$.
:::

<!-- illustrate difference between TS |= ~phi and TS ~|= phi -->

::: {#def-algo-ltl-model-checking}
### Algorithm for LTL Model Checking

Given an LTL-formula $\phi$ and a transition system $TS$.

1. Calculate a GNBA $G_{\neg \phi}$ that recognizes $\neg \phi$
2. Turn $G_{\neg \phi}$ into an equivalent NBA $A_{\neg \phi}$
3. Build the synchronous product $TS \otimes A_{\neg \phi}$
4. Check if $TS \otimes A_{\neg \phi} \models \dia \box \neg F$

Time complexity: $O( |TS| \cdot 2^{|\phi|} )$
:::

### Complexity landscape

First we define the considered problems.

LTL Model Checking Problem (`LTL-QUERY`)
: Given $TS$ and $\phi$. Does $TS \models \phi$?

LTL Satisfiability Problem (`LTL-SAT`)
: Given $\phi$. Does a $TS$ exists such that $TS \models \phi$?

LTL Validity Problem (`LTL-VALID)
: Givne $\phi$. Does it hold for all $TS$ that $TS \models \phi$? (Dual to LTL-SAT)

Further we recapitulate complexity classes.

`PSPACE`
: TM only needs polynomially large tape

`PSPACE-hard`
: All problems $P$ such that **every** problem from `PSPACE` can be reduced to $P$.

`PSPACE-complete`
: All problems that are in `PSPACE` and `PSPACE-hard`.


::: {#thm-co-np-hard}
The LTL model-checking and sat problem are co-NP-hard.
:::

::: {.callout-note collapse=true}
### Reducing `HAM-CYCLE` to LTL `UNSAT`

Because `HAM-CYCLE` is in NP we know that `LTL-SAT` is in co-NP.

$$\phi := \neg \left( \bigwedge_{v \in V} \dia v \land \box (v \rightarrow \next \box \neg v) \right)$$
:::

::: {#thm-pspace-complete}
The LTL model-checking problem is `PSPACE-complete`
:::

::: {.callout-note collapse=true}
### Proving `PSPACE-hard`ness of `LTL-QUERY`

:::

## Computation Tree Logic (CTL)