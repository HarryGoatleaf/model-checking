---
title: "Model Checking"
format:
  html:
    theme: darkly
    toc: true
    toc-depth: 3
    self-contained: false
---

\newcommand{\w}{\omega}

## Transition Systems

Intuition

Program | Automaton
:------:|:--------:
state | nodes
stepwise behaviour | transition
possible preconditions | init states
communication | actions 
atomic propositions | state properties

::: {#def-transition-system}
### Transition System

Formaly a transition system $T$ is a tuple $(S, Act, \rightarrow, S_0, AP, L)$
where

* $S$ countable set of **states**
* $Act$ set of **actions**
* $\rightarrow \ \subseteq S \times Act \times S$ a **transition relation**
* $S_0 \subseteq S$ a set of **initial states**
* set of **atomic propositions** $AP$ with
* a **labeling function** $L : S \rightarrow 2^{AP}$ that assigns propositions to each state
:::

::: {.callout-info}
### Differences to finite automata
* Possibly infinity state space.
* No accepting states.
* Multiple initial states.
:::

Execution Fragment
: An execution fragment of a transition system is an alternating sequence
  <!-- infinite??? -->
  sequence of states and actions:
$$ \rho = s_0 \alpha_1 s_1 \alpha_2 \ ... \text{ such that } s_i \xrightarrow{\alpha_{i+1}} s_{i+1}$$

Maximal
: An execution fragment is maximal iff. it is infinite or it is ending in a terminal state.

Initial
: An execution fragment is initial iff. it starts in an initial state.

Execution
: An execution is an initial & maximal execution fragment. (corresponds to run on automata)

Path
: Let $s_0 \alpha_1 s_1 ...$ be an execution, then $s_0s_1 ...$ is a path.
  In other words a path is the sequence of states of an execution.

Reachable fragment
: $Reach(T)$ set of states that appear on some path.

Trace
: Let $s_0s_1...$ be a path, then $L(s_0)L(s_1)...$ is a trace.
  In other words a trace is the sequence of atomic propositions that hold along a path.

### Program Graph

Program graphs are an abstraction of (imperative) programs.

::: {#def-program-graph}
#### Program Graph

A program graph is a tuple
$$(Loc, Act, Effect, \hookrightarrow, Loc_0, g_0)$$

where

* $Loc$ is a set of **locations** (roughtly corresponds to code lines)
* $Act$ is a set of **actions**
* $Effect: Act \times Eval(Var) \rightarrow Eval(Var)$ models the **effect** of actions
* $\hookrightarrow \subseteq Loc \times Cond(Var) \times Act \times Loc$ is the **edge relation**
* $g_0 \in Cond(Var)$ is the **initial condition**
:::

### Translating Program Graphs to Transition Systems

Let $PG = (Loc, Act, Effect, \hookrightarrow, Loc_0, g_0)$ be a program graph.
Then this can be modeled by the transition system $(S, Act, \rightarrow I, AP, L)$ where

* $S = Loc \times Eval(Var)$
* $\rightarrow \subseteq S \times Act \times S$ can be deduced by the following rule
  $$\frac{l \xhookrightarrow{g:\alpha} l' \land \eta \models g} {\langle l, \eta \rangle \xrightarrow{\alpha} \langle l', Effect(\alpha, \eta) \rangle}$$
* $I = \{ \langle l, \eta \rangle | l \in Loc_0, \eta \models g_0 \}$
* $L( \langle l, \eta \rangle) = \{l\} \cup \{g \in Cond(Var) | \eta \models g \}$

### Interleaving

We can model multi-threaded execution **without shared variables** by interleaving the transition systems.

::: {#def-interleaving-trans}
#### Interleaving transition systems

Let $TS_1, TS_2$ be two transition systems.
Then
$$TS_1 \ ||| \ TS_2 := (S_1 \times S_2, Act_1 \uplus Act_2, \rightarrow, I_1 \times I_2, AP_1 \uplus AP_2, L)$$

* $L(\langle s_1, s_2 \rangle) = L_1(s_1) \cup L_2(s_2)$
* And $\rightarrow$ can be deduced by the following rule:
  $$ 
  \frac{s_1 \xrightarrow{\alpha} s_1'} 
  {\langle s_1, \textcolor{gray}{s_2} \rangle \xrightarrow{\alpha} \langle s_1', \textcolor{gray}{s_2}\rangle}
  \text{ and }
  \frac{s_2 \xrightarrow{\alpha} s_2'} 
  {\langle \textcolor{gray}{s_1}, s_2 \rangle \xrightarrow{\alpha} \langle \textcolor{gray}{s_1}, s_2'\rangle}
  $$
:::

We can model multi-threaded execution **with shared variables** by interleaving the program graphs.

::: {#def-interleaving-prog}
#### Interleaving program graphs

Let $PG_1, PG_2$ be two program graphs over the **same variables**. Then
$PG_1 \ ||| \ PG_2 := (Loc_1 \times Loc_2, Act_1 \uplus Act_2, Effect, \hookrightarrow,$ \
$Loc_{0,1} \uplus Loc_{0,2}, g_{0, 1} \land g_{0, 2})$

* $Effect(\alpha, \eta) = Effect_i(\alpha, \eta)$ for $\alpha \in Act_i$.
* And $\hookrightarrow$ can be deduced by the following rule:
  $$ 
  \frac{l_1 \xhookrightarrow{g:\alpha} l_1'} 
  {\langle l_1, \textcolor{gray}{l_2} \rangle \xhookrightarrow{g:\alpha} \langle l_1', \textcolor{gray}{l_2}\rangle}
  \text{ and }
  \frac{l_2 \xhookrightarrow{g:\alpha} l_2'} 
  {\langle \textcolor{gray}{l_1}, l_2 \rangle \xhookrightarrow{g:\alpha} \langle \textcolor{gray}{l_1}, l_2'\rangle}
  $$
:::

::: {.callout-important}
In general it **does not hold** that $TS(PG_1) \ ||| \ TS(PG_1) = TS(PG_1 \ ||| \ PG_2)$
:::

::: {.callout-warning}
#### State Explosion Problem
State space grows **exponentially** with number of **threads** and **variables**.
:::

## Linear Time Properties

::: {#def-linear-time-property}
### Linear Time Property
A **linear-time property** over some atomic propositions $AP$ is a subset of 
$\left(2^{AP}\right)^\omega$.

A transitionsystem $TS$ satisfies a LT property $P$ 

$$TS \models P \text{iff. } Traces(TS) \subseteq P$$
:::

Invariant
: LT property of the form $A^\w$ for some $A \subseteq 2^{AP}$ i.e.
  "some property holds forever"

Persistance Property
: LT property of the form ${(2^{AP})}^* A^\w$ i.e.
  "some property eventually holds forever"

Closure
: For a LT property $P$ the closure contains all traces $t$ such that
  for each prefix of $t$ a trace in $P$ has the same prefix.

<!-- example -->

::: {#def-safety-property}
### Safety Property
A LT property $S$ over AP is a **safety property** if for all
$\sigma \in (2^{AP})^\omega \setminus S$
we can find a "bad prefix" $\hat{\sigma}$
such that no word in $S$ has prefix $\hat{\sigma}$

$$ cl(S) = S $$
:::

Trace Equivalence != Finite Trace Equivalence
<!-- TODO: note -->

::: {#def-liveness-property}
### Liveness Property
LT property $L$ over $AP$ is a **liveness property** iff.

$$pref(L) = {2^{AP}}^*$$
:::

::: {#def-w-regular-expression}
#### $\w$-regular Expression
An $\w$-regular expression has the form:

$$G = E_1.F_1^\w + ... + E_n.F_n^\w$$

where $E_i, F_i$ are regular expressions.

If a LT property can be defined by an $\w$-regular expression
we call it $\w$-*regular property*
:::

::: {#thm-trace-inclusion-lt-properties}
Let $TS, TS'$ be transition systems without terminal states:

\begin{align}
Traces(TS) \quad & \subseteq \quad Traces(TS') \\
& \text{iff.} \\
TS' \models P \quad & \Rightarrow \quad TS \models P 
, \text{ for all LT-props } P\\
\end{align}

For **safety property** we know that:

\begin{align}
Traces_{fin}(TS) \quad & \subseteq \quad Traces_{fin}(TS') \\
& \text{iff.} \\
TS' \models P \quad & \Rightarrow \quad TS \models P 
, \text{ for all \textbf{safety} props } P\\
\end{align}

:::

::: {#cor-trace-equivalence}
$Traces(TS) = Traces(TS')$ iff. $TS$ and $TS'$ satisfy the same LT properties and analogously \
$Traces_{fin}(TS) = Traces_{fin}(TS')$ iff. $TS$ and $TS'$
satisfy the same safety properties.
:::

::: {#lem-finite-image-trace}
If $TS'$ is image finite (ger: endlich verzweigt) we know that:

$$Traces(TS) \subseteq Traces(TS') \Leftrightarrow
  Traces_{fin}(TS) \subseteq Traces_{fin}(TS')$$
:::

::: {#def-synchronous-product}
#### Synchronous Product
Let:

* $TS := (S, Act, \rightharpoonup, I, AP, L)$ without terminal states
* $A := (Q, \Sigma, \rightharpoondown, Q_0, F)$ and NFA
  * $\Sigma = 2^{AP}$ i.e. defines trace prefixes
  * $Q_0 \cap F = \emptyset$

Let $TS$ be a transition system without terminal states and \
$A$ an NFA with $\Sigma = 2^{AP}$ and $Q_0 \cap F = \emptyset$

Then:

$$TS \otimes A := (S', Act, \rightarrow, I', AP', L')$$

* $S' = S \times Q$
* $AP' = Q$
* $L'( \langle s, q \rangle) = \{q\}$
* $\rightarrow$ can be deduced by:

$$\frac{s \xrightharpoonup{\alpha} \textcolor{orange}{t} \land q \xrightharpoondown{L(\textcolor{orange}{t})} p} {\langle {s}, {q} \rangle \xrightarrow{\alpha} \langle {\textcolor{orange}{t}}, {p} \rangle}$$

* $I' =  \{ \langle s_0, q \rangle | s_0 \in I \land \exists q_0 \in Q_0 . q_0 \xrightharpoondown{L(s_0)} q \}$
:::

::: {#thm-verifying-regular-safety-properties}
Let $TS$ be some transition system. $E_{safe}$ a safety property
and $A$ an NFA that recognizes the bad prefixes of $E_{safe}$.
Then:

$$TS \models E_{safe} \Leftrightarrow TS \otimes A \text{ has no reachable accepting states}$$
:::

::: {#def-buechi-automaton}
#### Büchi automaton

A *nondeterministic Büchi automaton* (NBA) is a tuple
$(Q, \Sigma, \delta, Q_0, F)$ where:

* $Q$ is a finite set of **states**
* $\Sigma$ is a finite **alphabet**
* $\delta: Q \times \Sigma \rightarrow 2^Q$ a **transition function**
* $Q_0 \subseteq Q$ a set of **initial states**
* $F \subseteq Q$ set of **accepting states**

**Acceptance condition**: There exists a run that **infinitely often** visits an
accepting state.
:::

Property       | NFA                        | NBA
---------------|----------------------------|----------------------------
Recognizes:    | regular languages          | $\w$-regular languages
Closure $\cup$ | union operator             | union operator
Closure $\cap$ | product construction       | GNBA product
Closure $\neg$ | build DFA and complement F | complex procedure
Determinism    | NFA = DFA                  | DBA $\subsetneq$ NBA

: NFA vs. NBA

<!-- lecture 6 start -->
## Verifying $\w$-regular Safety Properties

Idea
: Define Büchi automaton $\mathfrak{A}$ for _bad behaviour_ $E$.
  The atomic property $F$ labels all _accepting_ states of $\mathfrak{A}$. Check if 
  $$T \otimes \mathfrak{A} \models \text{ eventually forever } \neg F$$
  Here $\otimes$ is defined like in @def-synchronous-product.

::: {#thm-persistence-prop-check}
### Persistence Property Check

Let $P$ be some _persistence property_ of the form "$\text{eventually forever } \phi$".
Then it equivalent:

1. $\Leftrightarrow TS \models P$
2. $\Leftrightarrow \exists s. (s \in \text{Reach}(TS) \land s \not \models \phi \land s \text{ is on cycle})$
3. $\Leftrightarrow \exists C. (C \text{ is reachable } \land C \text{ is a SCC} \land C \cap \{ s \in S | s \not \models \phi \} \neq \emptyset)$

Strongly Connected Component ([SCC](https://en.wikipedia.org/wiki/Strongly_connected_component))
: Set of **states** $C$ such that for all $x, y \in C$: $x$ is _reachable_ from $y$.

### SCC Method

* compute all _inclusion maximal_ SCCs
* remove unreachable SCCs
* check for a state $s \models \neg \phi$

::: {.callout-caution}
#### Not practical
:::

### Cycle Method

**Naïve way:** $\Theta(|V| \cdot |E|)$

* use [DFS](https://en.wikipedia.org/wiki/Depth-first_search) to find states $s \models \neg \phi$
* use _second_ DFS to check wether cycle is reachable from itself (i.e. belongs to cycle)

**Imprövement:** $\Theta(|V| + |E|)$

* use outer DFS to find states $s \models \neg \phi$
* use inner DFS to check wether cycle is reachable from itself **while avoiding states visited in a previous inner DFS**, i.e. maintain **one** `visited` set across all executions of the inner DFS.

:::


<!-- lecture 6 end -->

## Linear Temporal Logic (LTL)

* $\phi = x | \phi \lor \phi | \neg \phi$
* $\phi = \Box \phi$ "always"
* $\phi = \bigcirc \phi$ "next"
* $\phi = \diamond \phi$ "eventually"
* $\phi = \phi \textbf{U} \phi$ "until"