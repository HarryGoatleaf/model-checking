<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-99.9.9">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Model Checking</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
span.underline{text-decoration: underline;}
div.column{display: inline-block; vertical-align: top; width: 50%;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
</style>


<script src="notes_files/libs/clipboard/clipboard.min.js"></script>
<script src="notes_files/libs/quarto-html/quarto.js"></script>
<script src="notes_files/libs/quarto-html/popper.min.js"></script>
<script src="notes_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="notes_files/libs/quarto-html/anchor.min.js"></script>
<link href="notes_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="notes_files/libs/quarto-html/quarto-syntax-highlighting-dark.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="notes_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="notes_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="notes_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet">

  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

</head>

<body>

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">
<div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
  <nav id="TOC" role="doc-toc">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#transition-systems" id="toc-transition-systems" class="nav-link active" data-scroll-target="#transition-systems">Transition Systems</a>
  <ul class="collapse">
  <li><a href="#program-graph" id="toc-program-graph" class="nav-link" data-scroll-target="#program-graph">Program Graph</a></li>
  <li><a href="#translating-program-graphs-to-transition-systems" id="toc-translating-program-graphs-to-transition-systems" class="nav-link" data-scroll-target="#translating-program-graphs-to-transition-systems">Translating Program Graphs to Transition Systems</a></li>
  <li><a href="#interleaving" id="toc-interleaving" class="nav-link" data-scroll-target="#interleaving">Interleaving</a></li>
  </ul></li>
  <li><a href="#linear-time-properties" id="toc-linear-time-properties" class="nav-link" data-scroll-target="#linear-time-properties">Linear Time Properties</a></li>
  <li><a href="#verifying-omega-regular-safety-properties" id="toc-verifying-omega-regular-safety-properties" class="nav-link" data-scroll-target="#verifying-omega-regular-safety-properties">Verifying <span class="math inline">\(\omega\)</span>-regular Safety Properties</a></li>
  <li><a href="#linear-temporal-logic-ltl" id="toc-linear-temporal-logic-ltl" class="nav-link" data-scroll-target="#linear-temporal-logic-ltl">Linear Temporal Logic (LTL)</a></li>
  <li><a href="#model-checking-of-ltl" id="toc-model-checking-of-ltl" class="nav-link" data-scroll-target="#model-checking-of-ltl">Model checking of LTL</a>
  <ul class="collapse">
  <li><a href="#complexity-landscape" id="toc-complexity-landscape" class="nav-link" data-scroll-target="#complexity-landscape">Complexity landscape</a></li>
  </ul></li>
  <li><a href="#computation-tree-logic-ctl" id="toc-computation-tree-logic-ctl" class="nav-link" data-scroll-target="#computation-tree-logic-ctl">Computation Tree Logic (CTL)</a>
  <ul class="collapse">
  <li><a href="#ctl-model-checking" id="toc-ctl-model-checking" class="nav-link" data-scroll-target="#ctl-model-checking">CTL Model Checking</a></li>
  <li><a href="#simulation-and-bisimulation" id="toc-simulation-and-bisimulation" class="nav-link" data-scroll-target="#simulation-and-bisimulation">Simulation and Bisimulation</a></li>
  <li><a href="#bisimilar-states" id="toc-bisimilar-states" class="nav-link" data-scroll-target="#bisimilar-states">Bisimilar states</a></li>
  <li><a href="#ap-deterministic" id="toc-ap-deterministic" class="nav-link" data-scroll-target="#ap-deterministic">AP-deterministic</a></li>
  <li><a href="#trace-equivalence-vs-bisimularity" id="toc-trace-equivalence-vs-bisimularity" class="nav-link" data-scroll-target="#trace-equivalence-vs-bisimularity">Trace equivalence vs Bisimularity</a></li>
  <li><a href="#bisimulation-and-ctl" id="toc-bisimulation-and-ctl" class="nav-link" data-scroll-target="#bisimulation-and-ctl">Bisimulation and CTL</a></li>
  </ul></li>
  <li><a href="#fairness" id="toc-fairness" class="nav-link" data-scroll-target="#fairness">Fairness</a>
  <ul class="collapse">
  <li><a href="#types-of-fairness" id="toc-types-of-fairness" class="nav-link" data-scroll-target="#types-of-fairness">Types of Fairness</a></li>
  <li><a href="#realisable-fairness" id="toc-realisable-fairness" class="nav-link" data-scroll-target="#realisable-fairness">Realisable Fairness</a></li>
  <li><a href="#model-checking-problems" id="toc-model-checking-problems" class="nav-link" data-scroll-target="#model-checking-problems">Model Checking Problems</a></li>
  </ul></li>
  </ul>
</nav>
</div>
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Model Checking</h1>
</div>



<div class="quarto-title-meta">

    
    
  </div>
  

</header>

<section id="transition-systems" class="level2">
<h2 class="anchored" data-anchor-id="transition-systems">Transition Systems</h2>
<p>Intuition</p>
<table class="table">
<thead>
<tr class="header">
<th style="text-align: center;">Program</th>
<th style="text-align: center;">Automaton</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">state</td>
<td style="text-align: center;">nodes</td>
</tr>
<tr class="even">
<td style="text-align: center;">stepwise behaviour</td>
<td style="text-align: center;">transition</td>
</tr>
<tr class="odd">
<td style="text-align: center;">possible preconditions</td>
<td style="text-align: center;">init states</td>
</tr>
<tr class="even">
<td style="text-align: center;">communication</td>
<td style="text-align: center;">actions</td>
</tr>
<tr class="odd">
<td style="text-align: center;">atomic propositions</td>
<td style="text-align: center;">state properties</td>
</tr>
</tbody>
</table>
<div id="def-transition-system" class="theorem definition">
<p><span class="theorem-title"><strong>Definition 1 (Transition System) </strong></span>Formaly a transition system <span class="math inline">\(T\)</span> is a tuple <span class="math inline">\((S, Act, \rightarrow, S_0, AP, L)\)</span> where</p>
<ul>
<li><span class="math inline">\(S\)</span> countable set of <strong>states</strong></li>
<li><span class="math inline">\(Act\)</span> set of <strong>actions</strong></li>
<li><span class="math inline">\(\rightarrow \ \subseteq S \times Act \times S\)</span> a <strong>transition relation</strong></li>
<li><span class="math inline">\(S_0 \subseteq S\)</span> a set of <strong>initial states</strong></li>
<li>set of <strong>atomic propositions</strong> <span class="math inline">\(AP\)</span> with</li>
<li>a <strong>labeling function</strong> <span class="math inline">\(L : S \rightarrow 2^{AP}\)</span> that assigns propositions to each state</li>
</ul>
</div>
<div class="callout-note callout callout-style-default callout-captioned">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-caption-container flex-fill">
Differences to finite automata
</div>
</div>
<div class="callout-body-container callout-body">
<ul>
<li>Possibly infinity state space.</li>
<li>No accepting states.</li>
<li>Multiple initial states.</li>
</ul>
</div>
</div>
<dl>
<dt>Execution Fragment</dt>
<dd>
An execution fragment of a transition system is an alternating sequence <!-- infinite??? --> sequence of states and actions:
</dd>
</dl>
<p><span class="math display">\[ \rho = s_0 \alpha_1 s_1 \alpha_2 \ ... \text{ such that } s_i \xrightarrow{\alpha_{i+1}} s_{i+1}\]</span></p>
<dl>
<dt>Maximal</dt>
<dd>
An execution fragment is maximal iff. it is infinite or it is ending in a terminal state.
</dd>
<dt>Initial</dt>
<dd>
An execution fragment is initial iff. it starts in an initial state.
</dd>
<dt>Execution</dt>
<dd>
An execution is an initial &amp; maximal execution fragment. (corresponds to run on automata)
</dd>
<dt>Path</dt>
<dd>
Let <span class="math inline">\(s_0 \alpha_1 s_1 ...\)</span> be an execution, then <span class="math inline">\(s_0s_1 ...\)</span> is a path. In other words a path is the sequence of states of an execution.
</dd>
<dt>Reachable fragment</dt>
<dd>
<span class="math inline">\(Reach(T)\)</span> set of states that appear on some path.
</dd>
<dt>Trace</dt>
<dd>
Let <span class="math inline">\(s_0s_1...\)</span> be a path, then <span class="math inline">\(L(s_0)L(s_1)...\)</span> is a trace. In other words a trace is the sequence of atomic propositions that hold along a path.
</dd>
</dl>
<section id="program-graph" class="level3">
<h3 class="anchored" data-anchor-id="program-graph">Program Graph</h3>
<p>Program graphs are an abstraction of (imperative) programs.</p>
<div id="def-program-graph" class="theorem definition">
<p><span class="theorem-title"><strong>Definition 2 (Program Graph) </strong></span>A program graph is a tuple</p>
<p><span class="math display">\[(Loc, Act, Effect, \hookrightarrow, Loc_0, g_0)\]</span></p>
<p>where</p>
<ul>
<li><span class="math inline">\(Loc\)</span> is a set of <strong>locations</strong> (roughtly corresponds to code lines)</li>
<li><span class="math inline">\(Act\)</span> is a set of <strong>actions</strong></li>
<li><span class="math inline">\(Effect: Act \times Eval(Var) \rightarrow Eval(Var)\)</span> models the <strong>effect</strong> of actions</li>
<li><span class="math inline">\(\hookrightarrow \subseteq Loc \times Cond(Var) \times Act \times Loc\)</span> is the <strong>edge relation</strong></li>
<li><span class="math inline">\(g_0 \in Cond(Var)\)</span> is the <strong>initial condition</strong></li>
</ul>
</div>
</section>
<section id="translating-program-graphs-to-transition-systems" class="level3">
<h3 class="anchored" data-anchor-id="translating-program-graphs-to-transition-systems">Translating Program Graphs to Transition Systems</h3>
<p>Let <span class="math inline">\(PG = (Loc, Act, Effect, \hookrightarrow, Loc_0, g_0)\)</span> be a program graph. Then this can be modeled by the transition system <span class="math inline">\((S, Act, \rightarrow I, AP, L)\)</span> where</p>
<ul>
<li><p><span class="math inline">\(S = Loc \times Eval(Var)\)</span></p></li>
<li><p><span class="math inline">\(\rightarrow \subseteq S \times Act \times S\)</span> can be deduced by the following rule</p>
<p><span class="math display">\[\frac{l \xhookrightarrow{g:\alpha} l' \land \eta \models g} {\langle l, \eta \rangle \xrightarrow{\alpha} \langle l', Effect(\alpha, \eta) \rangle}\]</span></p></li>
<li><p><span class="math inline">\(I = \{ \langle l, \eta \rangle | l \in Loc_0, \eta \models g_0 \}\)</span></p></li>
<li><p><span class="math inline">\(L( \langle l, \eta \rangle) = \{l\} \cup \{g \in Cond(Var) | \eta \models g \}\)</span></p></li>
</ul>
</section>
<section id="interleaving" class="level3">
<h3 class="anchored" data-anchor-id="interleaving">Interleaving</h3>
<p>We can model multi-threaded execution <strong>without shared variables</strong> by interleaving the transition systems.</p>
<div id="def-interleaving-trans" class="theorem definition">
<p><span class="theorem-title"><strong>Definition 3 (Interleaving transition systems) </strong></span>Let <span class="math inline">\(TS_1, TS_2\)</span> be two transition systems. Then</p>
<p><span class="math display">\[TS_1 \ ||| \ TS_2 := (S_1 \times S_2, Act_1 \uplus Act_2, \rightarrow, I_1 \times I_2, AP_1 \uplus AP_2, L)\]</span></p>
<ul>
<li><span class="math inline">\(L(\langle s_1, s_2 \rangle) = L_1(s_1) \cup L_2(s_2)\)</span></li>
<li>And <span class="math inline">\(\rightarrow\)</span> can be deduced by the following rule: <span class="math display">\[
\frac{s_1 \xrightarrow{\alpha} s_1'}
{\langle s_1, \textcolor{gray}{s_2} \rangle \xrightarrow{\alpha} \langle s_1', \textcolor{gray}{s_2}\rangle}
\text{ and }
\frac{s_2 \xrightarrow{\alpha} s_2'}
{\langle \textcolor{gray}{s_1}, s_2 \rangle \xrightarrow{\alpha} \langle \textcolor{gray}{s_1}, s_2'\rangle}
\]</span></li>
</ul>
</div>
<p>We can model multi-threaded execution <strong>with shared variables</strong> by interleaving the program graphs.</p>
<div id="def-interleaving-prog" class="theorem definition">
<p><span class="theorem-title"><strong>Definition 4 (Interleaving program graphs) </strong></span>Let <span class="math inline">\(PG_1, PG_2\)</span> be two program graphs over the <strong>same variables</strong>. Then <span class="math inline">\(PG_1 \ ||| \ PG_2 := (Loc_1 \times Loc_2, Act_1 \uplus Act_2, Effect, \hookrightarrow,\)</span><br>
<span class="math inline">\(Loc_{0,1} \uplus Loc_{0,2}, g_{0, 1} \land g_{0, 2})\)</span></p>
<ul>
<li><span class="math inline">\(Effect(\alpha, \eta) = Effect_i(\alpha, \eta)\)</span> for <span class="math inline">\(\alpha \in Act_i\)</span>.</li>
<li>And <span class="math inline">\(\hookrightarrow\)</span> can be deduced by the following rule: <span class="math display">\[
\frac{l_1 \xhookrightarrow{g:\alpha} l_1'}
{\langle l_1, \textcolor{gray}{l_2} \rangle \xhookrightarrow{g:\alpha} \langle l_1', \textcolor{gray}{l_2}\rangle}
\text{ and }
\frac{l_2 \xhookrightarrow{g:\alpha} l_2'}
{\langle \textcolor{gray}{l_1}, l_2 \rangle \xhookrightarrow{g:\alpha} \langle \textcolor{gray}{l_1}, l_2'\rangle}
\]</span></li>
</ul>
</div>
<div class="callout-important callout callout-style-default callout-captioned">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-caption-container flex-fill">
Important
</div>
</div>
<div class="callout-body-container callout-body">
<p>In general it <strong>does not hold</strong> that <span class="math inline">\(TS(PG_1) \ ||| \ TS(PG_1) = TS(PG_1 \ ||| \ PG_2)\)</span></p>
</div>
</div>
<div class="callout-warning callout callout-style-default callout-captioned">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-caption-container flex-fill">
State Explosion Problem
</div>
</div>
<div class="callout-body-container callout-body">
<p>State space grows <strong>exponentially</strong> with number of <strong>threads</strong> and <strong>variables</strong>.</p>
</div>
</div>
</section>
</section>
<section id="linear-time-properties" class="level2">
<h2 class="anchored" data-anchor-id="linear-time-properties">Linear Time Properties</h2>
<div id="def-linear-time-property" class="theorem definition">
<p><span class="theorem-title"><strong>Definition 5 (Linear Time Property) </strong></span>A <strong>linear-time property</strong> over some atomic propositions <span class="math inline">\(AP\)</span> is a subset of <span class="math inline">\(\left(2^{AP}\right)^\omega\)</span>.</p>
<p>A transitionsystem <span class="math inline">\(TS\)</span> satisfies a LT property <span class="math inline">\(P\)</span></p>
<p><span class="math display">\[TS \models P \text{ iff. } Traces(TS) \subseteq P\]</span></p>
</div>
<dl>
<dt>Invariant</dt>
<dd>
LT property of the form <span class="math inline">\(A^\omega\)</span> for some <span class="math inline">\(A \subseteq 2^{AP}\)</span> i.e. “some property holds forever”
</dd>
<dt>Persistance Property</dt>
<dd>
LT property of the form <span class="math inline">\({(2^{AP})}^* A^\omega\)</span> i.e. “some property eventually holds forever”
</dd>
<dt>Closure</dt>
<dd>
For a LT property <span class="math inline">\(P\)</span> the closure contains all traces <span class="math inline">\(t\)</span> such that for each prefix of <span class="math inline">\(t\)</span> a trace in <span class="math inline">\(P\)</span> has the same prefix.
</dd>
</dl>
<!-- example -->
<div id="def-safety-property" class="theorem definition">
<p><span class="theorem-title"><strong>Definition 6 (Safety Property) </strong></span>A LT property <span class="math inline">\(S\)</span> over AP is a <strong>safety property</strong> if for all <span class="math inline">\(\sigma \in (2^{AP})^\omega \setminus S\)</span> we can find a “bad prefix” <span class="math inline">\(\hat{\sigma}\)</span> such that no word in <span class="math inline">\(S\)</span> has prefix <span class="math inline">\(\hat{\sigma}\)</span></p>
<p><span class="math display">\[ cl(S) = S \]</span></p>
</div>
<p>Trace Equivalence != Finite Trace Equivalence <!-- TODO: note --></p>
<div id="def-liveness-property" class="theorem definition">
<p><span class="theorem-title"><strong>Definition 7 (Liveness Property) </strong></span>LT property <span class="math inline">\(L\)</span> over <span class="math inline">\(AP\)</span> is a <strong>liveness property</strong> iff.</p>
<p><span class="math display">\[pref(L) = {2^{AP}}^*\]</span></p>
</div>
<div id="def-w-regular-expression" class="theorem definition">
<p><span class="theorem-title"><strong>Definition 8 (<span class="math inline">\(\omega\)</span>-regular Expression) </strong></span>An <span class="math inline">\(\omega\)</span>-regular expression has the form:</p>
<p><span class="math display">\[G = E_1.F_1^\omega+ ... + E_n.F_n^\omega\]</span></p>
<p>where <span class="math inline">\(E_i, F_i\)</span> are regular expressions.</p>
<p>If a LT property can be defined by an <span class="math inline">\(\omega\)</span>-regular expression we call it <span class="math inline">\(\omega\)</span>-<em>regular property</em></p>
</div>
<div id="thm-trace-inclusion-lt-properties" class="theorem">
<p><span class="theorem-title"><strong>Theorem 1 </strong></span>Let <span class="math inline">\(TS, TS'\)</span> be transition systems without terminal states:</p>
<p><span class="math display">\[\begin{align}
Traces(TS) \quad &amp; \subseteq \quad Traces(TS') \\
&amp; \text{iff.} \\
TS' \models P \quad &amp; \Rightarrow \quad TS \models P
, \text{ for all LT-props } P\\
\end{align}\]</span></p>
<p>For <strong>safety property</strong> we know that:</p>
<p><span class="math display">\[\begin{align}
Traces_{fin}(TS) \quad &amp; \subseteq \quad Traces_{fin}(TS') \\
&amp; \text{iff.} \\
TS' \models P \quad &amp; \Rightarrow \quad TS \models P
, \text{ for all \textbf{safety} props } P\\
\end{align}\]</span></p>
</div>
<div id="cor-trace-equivalence" class="theorem corollary">
<p><span class="theorem-title"><strong>Corollary 1 </strong></span></p>
<p><span class="math inline">\(Traces(TS) = Traces(TS')\)</span> iff. <span class="math inline">\(TS\)</span> and <span class="math inline">\(TS'\)</span> satisfy the same LT properties and analogously<br>
<span class="math inline">\(Traces_{fin}(TS) = Traces_{fin}(TS')\)</span> iff. <span class="math inline">\(TS\)</span> and <span class="math inline">\(TS'\)</span> satisfy the same safety properties.</p>
</div>
<div id="lem-finite-image-trace" class="theorem lemma">
<p><span class="theorem-title"><strong>Lemma 1 </strong></span>If <span class="math inline">\(TS'\)</span> is image finite (ger: endlich verzweigt) we know that:</p>
<p><span class="math display">\[Traces(TS) \subseteq Traces(TS') \Leftrightarrow
  Traces_{fin}(TS) \subseteq Traces_{fin}(TS')\]</span></p>
</div>
<div id="def-synchronous-product" class="theorem definition">
<p><span class="theorem-title"><strong>Definition 9 (Synchronous Product) </strong></span>Let:</p>
<ul>
<li><span class="math inline">\(TS := (S, Act, \rightharpoonup, I, AP, L)\)</span> without terminal states</li>
<li><span class="math inline">\(A := (Q, \Sigma, \rightharpoondown, Q_0, F)\)</span> and NFA
<ul>
<li><span class="math inline">\(\Sigma = 2^{AP}\)</span> i.e.&nbsp;defines trace prefixes</li>
<li><span class="math inline">\(Q_0 \cap F = \emptyset\)</span></li>
</ul></li>
</ul>
<p>Let <span class="math inline">\(TS\)</span> be a transition system without terminal states and<br>
<span class="math inline">\(A\)</span> an NFA with <span class="math inline">\(\Sigma = 2^{AP}\)</span> and <span class="math inline">\(Q_0 \cap F = \emptyset\)</span></p>
<p>Then:</p>
<p><span class="math display">\[TS \otimes A := (S', Act, \rightarrow, I', AP', L')\]</span></p>
<ul>
<li><span class="math inline">\(S' = S \times Q\)</span></li>
<li><span class="math inline">\(AP' = Q\)</span></li>
<li><span class="math inline">\(L'( \langle s, q \rangle) = \{q\}\)</span></li>
<li><span class="math inline">\(\rightarrow\)</span> can be deduced by:</li>
</ul>
<p><span class="math display">\[\frac{s \xrightharpoonup{\alpha} \textcolor{orange}{t} \land q \xrightharpoondown{L(\textcolor{orange}{t})} p} {\langle {s}, {q} \rangle \xrightarrow{\alpha} \langle {\textcolor{orange}{t}}, {p} \rangle}\]</span></p>
<ul>
<li><span class="math inline">\(I' = \{ \langle s_0, q \rangle | s_0 \in I \land \exists q_0 \in Q_0 . q_0 \xrightharpoondown{L(s_0)} q \}\)</span></li>
</ul>
</div>
<div id="thm-verifying-regular-safety-properties" class="theorem">
<p><span class="theorem-title"><strong>Theorem 2 </strong></span>Let <span class="math inline">\(TS\)</span> be some transition system. <span class="math inline">\(E_{safe}\)</span> a safety property and <span class="math inline">\(A\)</span> an NFA that recognizes the bad prefixes of <span class="math inline">\(E_{safe}\)</span>. Then:</p>
<p><span class="math display">\[TS \models E_{safe} \Leftrightarrow TS \otimes A \text{ has no reachable accepting states}\]</span></p>
</div>
<div id="def-buechi-automaton" class="theorem definition">
<p><span class="theorem-title"><strong>Definition 10 (Büchi automaton) </strong></span>A <em>nondeterministic Büchi automaton</em> (NBA) is a tuple <span class="math inline">\((Q, \Sigma, \delta, Q_0, F)\)</span> where:</p>
<ul>
<li><span class="math inline">\(Q\)</span> is a finite set of <strong>states</strong></li>
<li><span class="math inline">\(\Sigma\)</span> is a finite <strong>alphabet</strong></li>
<li><span class="math inline">\(\delta: Q \times \Sigma \rightarrow 2^Q\)</span> a <strong>transition function</strong></li>
<li><span class="math inline">\(Q_0 \subseteq Q\)</span> a set of <strong>initial states</strong></li>
<li><span class="math inline">\(F \subseteq Q\)</span> set of <strong>accepting states</strong></li>
</ul>
<p><strong>Acceptance condition</strong>: There exists a run that <strong>infinitely often</strong> visits an accepting state.</p>
</div>
<table class="table">
<caption>NFA vs.&nbsp;NBA</caption>
<colgroup>
<col style="width: 21%">
<col style="width: 39%">
<col style="width: 39%">
</colgroup>
<thead>
<tr class="header">
<th>Property</th>
<th>NFA</th>
<th>NBA</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Recognizes:</td>
<td>regular languages</td>
<td><span class="math inline">\(\omega\)</span>-regular languages</td>
</tr>
<tr class="even">
<td>Closure <span class="math inline">\(\cup\)</span></td>
<td>union operator</td>
<td>union operator</td>
</tr>
<tr class="odd">
<td>Closure <span class="math inline">\(\cap\)</span></td>
<td>product construction</td>
<td>GNBA product</td>
</tr>
<tr class="even">
<td>Closure <span class="math inline">\(\neg\)</span></td>
<td>build DFA and complement F</td>
<td>complex procedure</td>
</tr>
<tr class="odd">
<td>Determinism</td>
<td>NFA = DFA</td>
<td>DBA <span class="math inline">\(\subsetneq\)</span> NBA</td>
</tr>
</tbody>
</table>
<!-- lecture 6 start -->
</section>
<section id="verifying-omega-regular-safety-properties" class="level2">
<h2 class="anchored" data-anchor-id="verifying-omega-regular-safety-properties">Verifying <span class="math inline">\(\omega\)</span>-regular Safety Properties</h2>
<dl>
<dt>Idea</dt>
<dd>
Define Büchi automaton <span class="math inline">\(\mathfrak{A}\)</span> for <em>bad behaviour</em> <span class="math inline">\(E\)</span>. The atomic property <span class="math inline">\(F\)</span> labels all <em>accepting</em> states of <span class="math inline">\(\mathfrak{A}\)</span>. Check if
</dd>
</dl>
<p><span class="math display">\[T \otimes \mathfrak{A} \models \text{ eventually forever } \neg F\]</span></p>
<p>Here <span class="math inline">\(\otimes\)</span> is defined like in <a href="#def-synchronous-product">Definition&nbsp;9</a>.</p>
<div id="thm-persistence-prop-check" class="theorem">
<p><span class="theorem-title"><strong>Theorem 3 (Persistence Property Check) </strong></span>Let <span class="math inline">\(P\)</span> be some <em>persistence property</em> of the form “<span class="math inline">\(\text{eventually forever } \varphi\)</span>”. Then it equivalent:</p>
<ol type="1">
<li><span class="math inline">\(\Leftrightarrow TS \models P\)</span></li>
<li><span class="math inline">\(\Leftrightarrow \exists s. (s \in \text{Reach}(TS) \land s \not \models \varphi\land s \text{ is on cycle})\)</span></li>
<li><span class="math inline">\(\Leftrightarrow \exists C. (C \text{ is reachable } \land C \text{ is a SCC} \land C \cap \{ s \in S | s \not \models \varphi\} \neq \emptyset)\)</span></li>
</ol>
<dl>
<dt>Strongly Connected Component (<a href="https://en.wikipedia.org/wiki/Strongly_connected_component">SCC</a>)</dt>
<dd>
Set of <strong>states</strong> <span class="math inline">\(C\)</span> such that for all <span class="math inline">\(x, y \in C\)</span>: <span class="math inline">\(x\)</span> is <em>reachable</em> from <span class="math inline">\(y\)</span>.
</dd>
</dl>
<section id="scc-method" class="level3">
<h3 class="anchored" data-anchor-id="scc-method">SCC Method</h3>
<ul>
<li>compute all <em>inclusion maximal</em> SCCs</li>
<li>remove unreachable SCCs</li>
<li>check for a state <span class="math inline">\(s \models \neg \varphi\)</span></li>
</ul>
<div class="callout-caution callout callout-style-default callout-captioned">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-caption-container flex-fill">
Not practical
</div>
</div>
<div class="callout-body-container callout-body">

</div>
</div>
</section>
<section id="cycle-method" class="level3">
<h3 class="anchored" data-anchor-id="cycle-method">Cycle Method</h3>
<p><strong>Naïve way:</strong> <span class="math inline">\(\Theta(|V| \cdot |E|)\)</span></p>
<ul>
<li>use <a href="https://en.wikipedia.org/wiki/Depth-first_search">DFS</a> to find states <span class="math inline">\(s \models \neg \varphi\)</span></li>
<li>use <em>second</em> DFS to check wether cycle is reachable from itself (i.e.&nbsp;belongs to cycle)</li>
</ul>
<p><strong>Imprövement:</strong> <span class="math inline">\(\Theta(|V| + |E|)\)</span></p>
<ul>
<li>use outer DFS to find states <span class="math inline">\(s \models \neg \varphi\)</span></li>
<li>use inner DFS to check wether cycle is reachable from itself <strong>while avoiding states visited in a previous inner DFS</strong>, i.e.&nbsp;maintain <strong>one</strong> <code>visited</code> set across all executions of the inner DFS.</li>
</ul>
</section>
</div>
<!-- lecture 6 end -->
</section>
<section id="linear-temporal-logic-ltl" class="level2">
<h2 class="anchored" data-anchor-id="linear-temporal-logic-ltl">Linear Temporal Logic (LTL)</h2>
<!-- macros -->
<!-- tomporal -->
<!-- modal -->
<p>For a set of atomic propositions <span class="math inline">\(AP\)</span> we give the BNF grammar for LTL:</p>
<ul>
<li><span class="math inline">\(\varphi= a \text{ for } a \in AP\)</span></li>
<li><span class="math inline">\(\varphi= \texttt{true}| \varphi\lor \varphi| \neg \varphi\)</span></li>
<li><span class="math inline">\(\varphi= \bigcirc\varphi\)</span> “next”</li>
<li><span class="math inline">\(\varphi= \varphi\textbf{U}\varphi\)</span> “until”</li>
</ul>
<p><strong>Derived Operators</strong>:</p>
<ul>
<li>the usual:<br>
<span class="math inline">\(\texttt{false}, \lor, \leftarrow, \rightarrow, \leftrightarrow, \otimes\)</span></li>
<li>modal operators:
<ul>
<li>“eventually” <span class="math inline">\(\diamond\varphi:= \texttt{true}\textbf{U}\varphi\)</span></li>
<li>“always” <span class="math inline">\(\square\varphi:= \neg \diamond\neg \varphi\)</span></li>
</ul></li>
<li>temporal operators:
<ul>
<li>“release” <span class="math inline">\(\varphi\textbf{R}\psi := \neg (\neg \varphi\textbf{U}\psi)\)</span></li>
<li>“weak until” <span class="math inline">\(\varphi\textbf{W}\psi := (\varphi\textbf{U}\psi) \lor \square\varphi\)</span></li>
<li>“strong release” <span class="math inline">\(\varphi\textbf{M}\psi := (\varphi\textbf{R}\psi) \land \diamond\varphi\)</span></li>
</ul></li>
</ul>
<p><strong>Equivalences</strong>:</p>
<p><strong>Dualities</strong>:</p>
<ul>
<li><span class="math inline">\(\neg \square\varphi\equiv \diamond\neg \varphi\)</span></li>
<li><span class="math inline">\(\neg \bigcirc\varphi\equiv \bigcirc\neg \varphi\)</span></li>
<li><span class="math inline">\(\neg (\varphi\textbf{U}\psi) \equiv \neg \varphi\textbf{R}\neg \psi\)</span></li>
<li><span class="math inline">\(\neg (\varphi\textbf{U}\psi) \equiv (\varphi\land \neg \psi) \textbf{R}(\neg \varphi\land \neg \psi)\)</span></li>
<li><span class="math inline">\(\neg (\varphi\textbf{W}\psi) \equiv \neg \varphi\textbf{M}\neg \psi\)</span></li>
<li><span class="math inline">\(\neg (\varphi\textbf{W}\psi) \equiv (\varphi\land \neg \psi) \textbf{U}(\neg \varphi\land \neg \psi)\)</span></li>
</ul>
<p><strong>Absorbtion</strong>:</p>
<ul>
<li><span class="math inline">\(\square\square\varphi\equiv \square\varphi\)</span></li>
<li><span class="math inline">\(\diamond\diamond\varphi\equiv \diamond\varphi\)</span></li>
<li><span class="math inline">\(\square\diamond\square\varphi\equiv \diamond\square\varphi\)</span></li>
<li><span class="math inline">\(\diamond\square\diamond\varphi\equiv \square\diamond\varphi\)</span></li>
<li><span class="math inline">\(\varphi\textbf{U}(\varphi\textbf{U}\psi) \equiv \varphi\textbf{U}\psi\)</span></li>
<li><span class="math inline">\((\varphi\textbf{U}\psi) \textbf{U}\psi \equiv \varphi\textbf{U}\psi\)</span></li>
</ul>
<p><strong>Distribution</strong>:</p>
<ul>
<li><span class="math inline">\(\bigcirc(\varphi\textbf{U}\psi) \equiv (\bigcirc\varphi\textbf{U}\bigcirc\psi)\)</span></li>
<li><span class="math inline">\(\diamond(\varphi\lor \psi) \equiv \diamond\varphi\lor \diamond\psi\)</span></li>
<li><span class="math inline">\(\square(\varphi\land \psi) \equiv \square\varphi\land \square\psi\)</span></li>
</ul>
<div class="callout-caution callout callout-style-default callout-captioned">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-caption-container flex-fill">
Danger
</div>
</div>
<div class="callout-body-container callout-body">
<ul>
<li><span class="math inline">\(\diamond(\varphi\land \psi) \not \equiv \diamond\varphi\land \diamond\psi\)</span></li>
<li><span class="math inline">\(\square(\varphi\lor \psi) \not \equiv \square\varphi\lor \square\psi\)</span></li>
</ul>
</div>
</div>
<p><strong>Expansion</strong>:</p>
<ul>
<li><span class="math inline">\(\diamond\varphi\equiv \varphi\lor \bigcirc\diamond\varphi\)</span></li>
<li><span class="math inline">\(\square\varphi\equiv \varphi\land \bigcirc\square\varphi\)</span></li>
<li><span class="math inline">\(\varphi\textbf{U}\psi \equiv \psi \lor (\varphi\land \bigcirc(\varphi\textbf{U}\psi))\)</span></li>
</ul>
<!-- TODO: formal semantics -->
<!-- TODO: examples -->
</section>
<section id="model-checking-of-ltl" class="level2">
<h2 class="anchored" data-anchor-id="model-checking-of-ltl">Model checking of LTL</h2>
<div id="def-gnba" class="theorem definition">
<p><span class="theorem-title"><strong>Definition 11 (Generalized Büchi Automata) </strong></span>A <em>Generalized Non-deterministic Büchi Automaton</em> (GNBA) is a tuple <span class="math inline">\((Q, \Sigma, \delta, Q_0, \mathfrak{F})\)</span> where</p>
<p><span class="math display">\[\mathfrak{F} = \{ F_1, ..., F_k \} \text{ with } F_i \subseteq Q\]</span></p>
<p>A run <span class="math inline">\(r_1r_2...\)</span> on this automaton is <strong>accepting</strong> if:</p>
<p><span class="math display">\[\forall F_j. \exists^\infty i. r_i \in F_j\]</span></p>
</div>
<div class="callout-note callout callout-style-default callout-captioned">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-caption-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<p>For NBA <span class="math inline">\(A\)</span> the NBA for <span class="math inline">\(\bar{A}\)</span> has <span class="math inline">\(c^{n^2}\)</span> states in worst case.</p>
<p>Solution: use <span class="math inline">\(A_{\neg \varphi} \equiv \bar{A}\)</span></p>
</div>
</div>
<p>expand <span class="math inline">\(\sigma = A_1A_2...\)</span> to <span class="math inline">\(B_1B_2...\)</span> where <span class="math inline">\(B_i = A_i \cup \{ \psi | \psi \models A_i, \psi \text{ subformula of } \varphi\}\)</span></p>
<dl>
<dt>Closure of LTL formula</dt>
<dd>
all subformulas and their negations
</dd>
</dl>
<div id="def-elementary-sets" class="theorem definition">
<p><span class="theorem-title"><strong>Definition 12 (Elementary sets) </strong></span>Let</p>
<ol type="1">
<li>maximaly consistent:</li>
</ol>
<ul>
<li><span class="math inline">\(\varphi\land \psi \in B \Leftrightarrow \varphi\in B \land \psi \in B\)</span></li>
<li><span class="math inline">\(\varphi\notin B \Leftrightarrow \neg \varphi\in B\)</span></li>
<li><span class="math inline">\(true \in cl(\varphi) \Rightarrow true \in B\)</span></li>
</ul>
<ol start="2" type="1">
<li>locally consistent: for <span class="math inline">\(\varphi U \psi \in cl(\sigma)\)</span></li>
</ol>
<ul>
<li><span class="math inline">\(\psi \in B \Rightarrow \varphi U \psi \in B\)</span></li>
<li><span class="math inline">\(\varphi U \psi \in B \land \psi \notin B \Rightarrow \varphi\in B\)</span></li>
</ul>
</div>
<ul>
<li><span class="math inline">\(\Sigma = 2^{AP}\)</span></li>
<li>$Q := $ elementary sets</li>
<li><span class="math inline">\(Q_0\)</span> all sets with <span class="math inline">\(\varphi\)</span></li>
<li>$:= $
<ul>
<li><span class="math inline">\(\circ \varphi\in B \Leftrightarrow \varphi\in B'\)</span></li>
<li>(expansion law) $U B (B (B U B’))</li>
</ul></li>
</ul>
<div class="callout-note callout callout-style-default callout-captioned">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-7-contents" aria-controls="callout-7" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-caption-container flex-fill">
Size of NBA can be exponential
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-7" class="callout-7-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p>The <strong>worst-case</strong> runtime for constructing an NBA that recognizes a formula is <strong>exponential</strong>. This is because the constructed NBA can be exponentially large. For example for <span class="math inline">\(n \in \mathbb{N}\)</span> consider</p>
<p><span class="math display">\[\varphi_n := \bigwedge_{a \in AP} \bigwedge_{0 \leq i &lt; n} (\bigcirc^i a \leftrightarrow \bigcirc^{n+i} a)\]</span></p>
<p>Intuitively we can see that after reading the first <span class="math inline">\(n\)</span> characters the automaton has to remember for all <span class="math inline">\(0 \leq i &lt; 0\)</span> and every <span class="math inline">\(a \in AP\)</span> if <span class="math inline">\(a\)</span> holds at position <span class="math inline">\(i\)</span>.</p>
</div>
</div>
</div>
<!-- illustrate difference between TS |= ~phi and TS ~|= phi -->
<div id="def-algo-ltl-model-checking" class="theorem definition">
<p><span class="theorem-title"><strong>Definition 13 (Algorithm for LTL Model Checking) </strong></span>Given an LTL-formula <span class="math inline">\(\varphi\)</span> and a transition system <span class="math inline">\(TS\)</span>.</p>
<ol type="1">
<li>Calculate a GNBA <span class="math inline">\(G_{\neg \varphi}\)</span> that recognizes <span class="math inline">\(\neg \varphi\)</span></li>
<li>Turn <span class="math inline">\(G_{\neg \varphi}\)</span> into an equivalent NBA <span class="math inline">\(A_{\neg \varphi}\)</span></li>
<li>Build the synchronous product <span class="math inline">\(TS \otimes A_{\neg \varphi}\)</span></li>
<li>Check if <span class="math inline">\(TS \otimes A_{\neg \varphi} \models \diamond\square\neg F\)</span></li>
</ol>
<p>Time complexity: <span class="math inline">\(O( |TS| \cdot 2^{|\varphi|} )\)</span></p>
</div>
<section id="complexity-landscape" class="level3">
<h3 class="anchored" data-anchor-id="complexity-landscape">Complexity landscape</h3>
<p>First we define the considered problems.</p>
<dl>
<dt>LTL Model Checking Problem (<code>LTL-QUERY</code>)</dt>
<dd>
Given <span class="math inline">\(TS\)</span> and <span class="math inline">\(\varphi\)</span>. Does <span class="math inline">\(TS \models \varphi\)</span>?
</dd>
<dt>LTL Satisfiability Problem (<code>LTL-SAT</code>)</dt>
<dd>
Given <span class="math inline">\(\varphi\)</span>. Does a <span class="math inline">\(TS\)</span> exists such that <span class="math inline">\(TS \models \varphi\)</span>?
</dd>
<dt>LTL Validity Problem (`LTL-VALID)</dt>
<dd>
Givne <span class="math inline">\(\varphi\)</span>. Does it hold for all <span class="math inline">\(TS\)</span> that <span class="math inline">\(TS \models \varphi\)</span>? (Dual to LTL-SAT)
</dd>
</dl>
<p>Further we recapitulate complexity classes.</p>
<dl>
<dt><code>PSPACE</code></dt>
<dd>
TM only needs polynomially large tape
</dd>
<dt><code>PSPACE-hard</code></dt>
<dd>
All problems <span class="math inline">\(P\)</span> such that <strong>every</strong> problem from <code>PSPACE</code> can be reduced to <span class="math inline">\(P\)</span>.
</dd>
<dt><code>PSPACE-complete</code></dt>
<dd>
All problems that are in <code>PSPACE</code> and <code>PSPACE-hard</code>.
</dd>
</dl>
<div id="thm-co-np-hard" class="theorem">
<p><span class="theorem-title"><strong>Theorem 4 </strong></span></p>
<p>The LTL model-checking and sat problem are co-NP-hard.</p>
</div>
<div class="callout-note callout callout-style-default callout-captioned">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-8-contents" aria-controls="callout-8" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-caption-container flex-fill">
Reducing <code>HAM-CYCLE</code> to LTL <code>UNSAT</code>
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-8" class="callout-8-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p>Because <code>HAM-CYCLE</code> is in NP we know that <code>LTL-SAT</code> is in co-NP.</p>
<p><span class="math display">\[\varphi:= \neg \left( \bigwedge_{v \in V} \diamond v \land \square(v \rightarrow \bigcirc\square\neg v) \right)\]</span></p>
</div>
</div>
</div>
<div id="thm-pspace-complete" class="theorem">
<p><span class="theorem-title"><strong>Theorem 5 </strong></span></p>
<p>The LTL model-checking problem is <code>PSPACE-complete</code></p>
</div>
<div class="callout-note callout callout-style-default callout-captioned">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-9-contents" aria-controls="callout-9" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-caption-container flex-fill">
Proving <code>PSPACE-hard</code>ness of <code>LTL-QUERY</code>
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-9" class="callout-9-contents callout-collapse collapse">
<div class="callout-body-container callout-body">

</div>
</div>
</div>
</section>
</section>
<section id="computation-tree-logic-ctl" class="level2">
<h2 class="anchored" data-anchor-id="computation-tree-logic-ctl">Computation Tree Logic (CTL)</h2>
<div id="def-ctl" class="theorem definition">
<p><span class="theorem-title"><strong>Definition 14 (CTL) </strong></span></p>
</div>
<div id="thm-from-ctl-to-ltl" class="theorem">
<p><span class="theorem-title"><strong>Theorem 6 (From CTL to LTL) </strong></span>Let <span class="math inline">\(\Phi\)</span> be a CTL-formula and <span class="math inline">\(\varphi\)</span> the LTL-formula obtained by deleting all quantifiers from <span class="math inline">\(\Phi\)</span>. Then:</p>
<p><span class="math display">\[\Phi \equiv \varphi\textbf{ or } \Phi \text{ is not definable in LTL}\]</span></p>
</div>
<div class="callout-tip callout callout-style-default callout-captioned">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-caption-container flex-fill">
From LTL to CTL
</div>
</div>
<div class="callout-body-container callout-body">
<p>tips</p>
</div>
</div>
<div id="def-ctl-star" class="theorem definition">
<p><span class="theorem-title"><strong>Definition 15 (CTL *) </strong></span></p>
</div>
<div id="def-ctl-plus" class="theorem definition">
<p><span class="theorem-title"><strong>Definition 16 (CTL +) </strong></span></p>
</div>
<div id="thm-clt-plus-comparison" class="theorem">
<p><span class="theorem-title"><strong>Theorem 7 (Comparison of CTL+) </strong></span></p>
</div>
<section id="ctl-model-checking" class="level3">
<h3 class="anchored" data-anchor-id="ctl-model-checking">CTL Model Checking</h3>
<p>Fixpoint iteration</p>
<p>PTIME Complete</p>
</section>
<section id="simulation-and-bisimulation" class="level3">
<h3 class="anchored" data-anchor-id="simulation-and-bisimulation">Simulation and Bisimulation</h3>
</section>
<section id="bisimilar-states" class="level3">
<h3 class="anchored" data-anchor-id="bisimilar-states">Bisimilar states</h3>
</section>
<section id="ap-deterministic" class="level3">
<h3 class="anchored" data-anchor-id="ap-deterministic">AP-deterministic</h3>
</section>
<section id="trace-equivalence-vs-bisimularity" class="level3">
<h3 class="anchored" data-anchor-id="trace-equivalence-vs-bisimularity">Trace equivalence vs Bisimularity</h3>
</section>
<section id="bisimulation-and-ctl" class="level3">
<h3 class="anchored" data-anchor-id="bisimulation-and-ctl">Bisimulation and CTL</h3>
<div id="thm-bisimilarity-ctl" class="theorem">
<p><span class="theorem-title"><strong>Theorem 8 </strong></span>For a <em>finitely branching</em> transition system TS and states <span class="math inline">\(s, s'\)</span> it is <strong>equivalent</strong>:</p>
<ul>
<li><span class="math inline">\(s \sim s'\)</span></li>
<li><span class="math inline">\(s \equiv_{CTL} s'\)</span></li>
<li><span class="math inline">\(s \equiv_{CTL*} s'\)</span></li>
</ul>
</div>
</section>
</section>
<section id="fairness" class="level2">
<h2 class="anchored" data-anchor-id="fairness">Fairness</h2>
<p>Fairness <strong>limits</strong> the set of traces we consider when doing model checking.</p>
<p>We want to remove traces that we consider <em>unrealistic</em>.</p>
<section id="types-of-fairness" class="level3">
<h3 class="anchored" data-anchor-id="types-of-fairness">Types of Fairness</h3>
<p>Which fairness notion?:</p>
<ul>
<li>strong fairness good for contentions</li>
<li>weak fairness good for unfair scheduling</li>
</ul>
</section>
<section id="realisable-fairness" class="level3">
<h3 class="anchored" data-anchor-id="realisable-fairness">Realisable Fairness</h3>
</section>
<section id="model-checking-problems" class="level3">
<h3 class="anchored" data-anchor-id="model-checking-problems">Model Checking Problems</h3>
<p>LTL Fairness Model Checking</p>
<ul>
<li>transition system <span class="math inline">\(TS\)</span></li>
<li>LTL formula <span class="math inline">\(\varphi\)</span></li>
<li>an LTL fairness assumption <span class="math inline">\(fair\)</span></li>
</ul>
<p>Question: does <span class="math inline">\(TS \models_{fair} \varphi\)</span></p>
<p>Can be reduced to normal model checking by considering <span class="math inline">\((fair \rightarrow \varphi)\)</span></p>
<p>CTL Fairness Model Checking</p>
<ul>
<li>transition system <span class="math inline">\(TS\)</span></li>
<li>CTL formula <span class="math inline">\(\varphi\)</span></li>
<li>an CTL fairness assumption <span class="math inline">\(fair\)</span></li>
</ul>
<p>Question: does <span class="math inline">\(TS \models_{fair} \varphi\)</span></p>
<p>include fairness checking by <strong>limiting</strong> <span class="math inline">\(\forall, \exists\)</span> quantifiers to <strong>fair paths</strong>.</p>
<p>How to change algo * add fresh atomic propositions for fairness conditions * when considering quantifiers check if the final path fragment is fair</p>
<p>How to compute <span class="math inline">\(SAT_{fair} (\exists \square a)\)</span></p>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    target: function(trigger) {
      return trigger.previousElementSibling;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    setTimeout(function() {
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      let href = ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const cites = ref.parentNode.getAttribute('data-cites').split(' ');
    tippyHover(ref, function() {
      var popup = window.document.createElement('div');
      cites.forEach(function(cite) {
        var citeDiv = window.document.createElement('div');
        citeDiv.classList.add('hanging-indent');
        citeDiv.classList.add('csl-entry');
        var biblioDiv = window.document.getElementById('ref-' + cite);
        if (biblioDiv) {
          citeDiv.innerHTML = biblioDiv.innerHTML;
        }
        popup.appendChild(citeDiv);
      });
      return popup.innerHTML;
    });
  }
});
</script>
</div> <!-- /content -->



</body></html>