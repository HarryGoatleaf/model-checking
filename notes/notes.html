<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-0.9.446">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Model Checking</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
span.underline{text-decoration: underline;}
div.column{display: inline-block; vertical-align: top; width: 50%;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
</style>

<script src="notes_files/libs/clipboard/clipboard.min.js"></script>
<script src="notes_files/libs/quarto-html/quarto.js"></script>
<script src="notes_files/libs/quarto-html/popper.min.js"></script>
<script src="notes_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="notes_files/libs/quarto-html/anchor.min.js"></script>
<link href="notes_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link id="quarto-text-highlighting-styles" href="notes_files/libs/quarto-html/quarto-syntax-highlighting-dark.css" rel="stylesheet">
<script src="notes_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="notes_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="notes_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet">

  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

</head>

<body>

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">
<div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
  <nav id="TOC" role="doc-toc">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#transition-systems" id="toc-transition-systems" class="nav-link active" data-scroll-target="#transition-systems">Transition Systems</a>
  <ul class="collapse">
  <li><a href="#program-graph" id="toc-program-graph" class="nav-link" data-scroll-target="#program-graph">Program Graph</a></li>
  <li><a href="#translating-program-graphs-to-transition-systems" id="toc-translating-program-graphs-to-transition-systems" class="nav-link" data-scroll-target="#translating-program-graphs-to-transition-systems">Translating Program Graphs to Transition Systems</a></li>
  <li><a href="#interleaving" id="toc-interleaving" class="nav-link" data-scroll-target="#interleaving">Interleaving</a></li>
  </ul></li>
  <li><a href="#linear-time-properties" id="toc-linear-time-properties" class="nav-link" data-scroll-target="#linear-time-properties">Linear Time Properties</a></li>
  <li><a href="#verifying-omega-regular-safety-properties" id="toc-verifying-omega-regular-safety-properties" class="nav-link" data-scroll-target="#verifying-omega-regular-safety-properties">Verifying <span class="math inline">\(\omega\)</span>-regular Safety Properties</a></li>
  <li><a href="#linear-temporal-logic-ltl" id="toc-linear-temporal-logic-ltl" class="nav-link" data-scroll-target="#linear-temporal-logic-ltl">Linear Temporal Logic (LTL)</a></li>
  <li><a href="#model-checking-of-ltl" id="toc-model-checking-of-ltl" class="nav-link" data-scroll-target="#model-checking-of-ltl">Model checking of LTL</a></li>
  </ul>
</nav>
</div>
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Model Checking</h1>
</div>



<div class="quarto-title-meta">

    
    
  </div>
  

</header>

<section id="transition-systems" class="level2">
<h2 class="anchored" data-anchor-id="transition-systems">Transition Systems</h2>
<p>Intuition</p>
<table class="table">
<thead>
<tr class="header">
<th style="text-align: center;">Program</th>
<th style="text-align: center;">Automaton</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">state</td>
<td style="text-align: center;">nodes</td>
</tr>
<tr class="even">
<td style="text-align: center;">stepwise behaviour</td>
<td style="text-align: center;">transition</td>
</tr>
<tr class="odd">
<td style="text-align: center;">possible preconditions</td>
<td style="text-align: center;">init states</td>
</tr>
<tr class="even">
<td style="text-align: center;">communication</td>
<td style="text-align: center;">actions</td>
</tr>
<tr class="odd">
<td style="text-align: center;">atomic propositions</td>
<td style="text-align: center;">state properties</td>
</tr>
</tbody>
</table>
<div id="def-transition-system" class="theorem definition">
<p><span class="theorem-title"><strong>Definition 1 (Transition System) </strong></span>Formaly a transition system <span class="math inline">\(T\)</span> is a tuple <span class="math inline">\((S, Act, \rightarrow, S_0, AP, L)\)</span> where</p>
<ul>
<li><span class="math inline">\(S\)</span> countable set of <strong>states</strong></li>
<li><span class="math inline">\(Act\)</span> set of <strong>actions</strong></li>
<li><span class="math inline">\(\rightarrow \ \subseteq S \times Act \times S\)</span> a <strong>transition relation</strong></li>
<li><span class="math inline">\(S_0 \subseteq S\)</span> a set of <strong>initial states</strong></li>
<li>set of <strong>atomic propositions</strong> <span class="math inline">\(AP\)</span> with</li>
<li>a <strong>labeling function</strong> <span class="math inline">\(L : S \rightarrow 2^{AP}\)</span> that assigns propositions to each state</li>
</ul>
</div>
<div class="callout-info callout callout-style-default no-icon callout-captioned">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-caption-container flex-fill">
Differences to finite automata
</div>
</div>
<div class="callout-body-container callout-body">
<ul>
<li>Possibly infinity state space.</li>
<li>No accepting states.</li>
<li>Multiple initial states.</li>
</ul>
</div>
</div>
<dl>
<dt>Execution Fragment</dt>
<dd>
An execution fragment of a transition system is an alternating sequence <!-- infinite??? --> sequence of states and actions:
</dd>
</dl>
<p><span class="math display">\[ \rho = s_0 \alpha_1 s_1 \alpha_2 \ ... \text{ such that } s_i \xrightarrow{\alpha_{i+1}} s_{i+1}\]</span></p>
<dl>
<dt>Maximal</dt>
<dd>
An execution fragment is maximal iff. it is infinite or it is ending in a terminal state.
</dd>
<dt>Initial</dt>
<dd>
An execution fragment is initial iff. it starts in an initial state.
</dd>
<dt>Execution</dt>
<dd>
An execution is an initial &amp; maximal execution fragment. (corresponds to run on automata)
</dd>
<dt>Path</dt>
<dd>
Let <span class="math inline">\(s_0 \alpha_1 s_1 ...\)</span> be an execution, then <span class="math inline">\(s_0s_1 ...\)</span> is a path. In other words a path is the sequence of states of an execution.
</dd>
<dt>Reachable fragment</dt>
<dd>
<span class="math inline">\(Reach(T)\)</span> set of states that appear on some path.
</dd>
<dt>Trace</dt>
<dd>
Let <span class="math inline">\(s_0s_1...\)</span> be a path, then <span class="math inline">\(L(s_0)L(s_1)...\)</span> is a trace. In other words a trace is the sequence of atomic propositions that hold along a path.
</dd>
</dl>
<section id="program-graph" class="level3">
<h3 class="anchored" data-anchor-id="program-graph">Program Graph</h3>
<p>Program graphs are an abstraction of (imperative) programs.</p>
<div id="def-program-graph" class="theorem definition">
<p><span class="theorem-title"><strong>Definition 2 (Program Graph) </strong></span>A program graph is a tuple</p>
<p><span class="math display">\[(Loc, Act, Effect, \hookrightarrow, Loc_0, g_0)\]</span></p>
<p>where</p>
<ul>
<li><span class="math inline">\(Loc\)</span> is a set of <strong>locations</strong> (roughtly corresponds to code lines)</li>
<li><span class="math inline">\(Act\)</span> is a set of <strong>actions</strong></li>
<li><span class="math inline">\(Effect: Act \times Eval(Var) \rightarrow Eval(Var)\)</span> models the <strong>effect</strong> of actions</li>
<li><span class="math inline">\(\hookrightarrow \subseteq Loc \times Cond(Var) \times Act \times Loc\)</span> is the <strong>edge relation</strong></li>
<li><span class="math inline">\(g_0 \in Cond(Var)\)</span> is the <strong>initial condition</strong></li>
</ul>
</div>
</section>
<section id="translating-program-graphs-to-transition-systems" class="level3">
<h3 class="anchored" data-anchor-id="translating-program-graphs-to-transition-systems">Translating Program Graphs to Transition Systems</h3>
<p>Let <span class="math inline">\(PG = (Loc, Act, Effect, \hookrightarrow, Loc_0, g_0)\)</span> be a program graph. Then this can be modeled by the transition system <span class="math inline">\((S, Act, \rightarrow I, AP, L)\)</span> where</p>
<ul>
<li><p><span class="math inline">\(S = Loc \times Eval(Var)\)</span></p></li>
<li><p><span class="math inline">\(\rightarrow \subseteq S \times Act \times S\)</span> can be deduced by the following rule</p>
<p><span class="math display">\[\frac{l \xhookrightarrow{g:\alpha} l' \land \eta \models g} {\langle l, \eta \rangle \xrightarrow{\alpha} \langle l', Effect(\alpha, \eta) \rangle}\]</span></p></li>
<li><p><span class="math inline">\(I = \{ \langle l, \eta \rangle | l \in Loc_0, \eta \models g_0 \}\)</span></p></li>
<li><p><span class="math inline">\(L( \langle l, \eta \rangle) = \{l\} \cup \{g \in Cond(Var) | \eta \models g \}\)</span></p></li>
</ul>
</section>
<section id="interleaving" class="level3">
<h3 class="anchored" data-anchor-id="interleaving">Interleaving</h3>
<p>We can model multi-threaded execution <strong>without shared variables</strong> by interleaving the transition systems.</p>
<div id="def-interleaving-trans" class="theorem definition">
<p><span class="theorem-title"><strong>Definition 3 (Interleaving transition systems) </strong></span>Let <span class="math inline">\(TS_1, TS_2\)</span> be two transition systems. Then</p>
<p><span class="math display">\[TS_1 \ ||| \ TS_2 := (S_1 \times S_2, Act_1 \uplus Act_2, \rightarrow, I_1 \times I_2, AP_1 \uplus AP_2, L)\]</span></p>
<ul>
<li><span class="math inline">\(L(\langle s_1, s_2 \rangle) = L_1(s_1) \cup L_2(s_2)\)</span></li>
<li>And <span class="math inline">\(\rightarrow\)</span> can be deduced by the following rule: <span class="math display">\[
\frac{s_1 \xrightarrow{\alpha} s_1'}
{\langle s_1, \textcolor{gray}{s_2} \rangle \xrightarrow{\alpha} \langle s_1', \textcolor{gray}{s_2}\rangle}
\text{ and }
\frac{s_2 \xrightarrow{\alpha} s_2'}
{\langle \textcolor{gray}{s_1}, s_2 \rangle \xrightarrow{\alpha} \langle \textcolor{gray}{s_1}, s_2'\rangle}
\]</span></li>
</ul>
</div>
<p>We can model multi-threaded execution <strong>with shared variables</strong> by interleaving the program graphs.</p>
<div id="def-interleaving-prog" class="theorem definition">
<p><span class="theorem-title"><strong>Definition 4 (Interleaving program graphs) </strong></span>Let <span class="math inline">\(PG_1, PG_2\)</span> be two program graphs over the <strong>same variables</strong>. Then <span class="math inline">\(PG_1 \ ||| \ PG_2 := (Loc_1 \times Loc_2, Act_1 \uplus Act_2, Effect, \hookrightarrow,\)</span><br>
<span class="math inline">\(Loc_{0,1} \uplus Loc_{0,2}, g_{0, 1} \land g_{0, 2})\)</span></p>
<ul>
<li><span class="math inline">\(Effect(\alpha, \eta) = Effect_i(\alpha, \eta)\)</span> for <span class="math inline">\(\alpha \in Act_i\)</span>.</li>
<li>And <span class="math inline">\(\hookrightarrow\)</span> can be deduced by the following rule: <span class="math display">\[
\frac{l_1 \xhookrightarrow{g:\alpha} l_1'}
{\langle l_1, \textcolor{gray}{l_2} \rangle \xhookrightarrow{g:\alpha} \langle l_1', \textcolor{gray}{l_2}\rangle}
\text{ and }
\frac{l_2 \xhookrightarrow{g:\alpha} l_2'}
{\langle \textcolor{gray}{l_1}, l_2 \rangle \xhookrightarrow{g:\alpha} \langle \textcolor{gray}{l_1}, l_2'\rangle}
\]</span></li>
</ul>
</div>
<div class="callout-important callout callout-style-default callout-captioned">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-caption-container flex-fill">
Important
</div>
</div>
<div class="callout-body-container callout-body">
<p>In general it <strong>does not hold</strong> that <span class="math inline">\(TS(PG_1) \ ||| \ TS(PG_1) = TS(PG_1 \ ||| \ PG_2)\)</span></p>
</div>
</div>
<div class="callout-warning callout callout-style-default callout-captioned">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-caption-container flex-fill">
State Explosion Problem
</div>
</div>
<div class="callout-body-container callout-body">
<p>State space grows <strong>exponentially</strong> with number of <strong>threads</strong> and <strong>variables</strong>.</p>
</div>
</div>
</section>
</section>
<section id="linear-time-properties" class="level2">
<h2 class="anchored" data-anchor-id="linear-time-properties">Linear Time Properties</h2>
<div id="def-linear-time-property" class="theorem definition">
<p><span class="theorem-title"><strong>Definition 5 (Linear Time Property) </strong></span>A <strong>linear-time property</strong> over some atomic propositions <span class="math inline">\(AP\)</span> is a subset of <span class="math inline">\(\left(2^{AP}\right)^\omega\)</span>.</p>
<p>A transitionsystem <span class="math inline">\(TS\)</span> satisfies a LT property <span class="math inline">\(P\)</span></p>
<p><span class="math display">\[TS \models P \text{ iff. } Traces(TS) \subseteq P\]</span></p>
</div>
<dl>
<dt>Invariant</dt>
<dd>
LT property of the form <span class="math inline">\(A^\omega\)</span> for some <span class="math inline">\(A \subseteq 2^{AP}\)</span> i.e. “some property holds forever”
</dd>
<dt>Persistance Property</dt>
<dd>
LT property of the form <span class="math inline">\({(2^{AP})}^* A^\omega\)</span> i.e. “some property eventually holds forever”
</dd>
<dt>Closure</dt>
<dd>
For a LT property <span class="math inline">\(P\)</span> the closure contains all traces <span class="math inline">\(t\)</span> such that for each prefix of <span class="math inline">\(t\)</span> a trace in <span class="math inline">\(P\)</span> has the same prefix.
</dd>
</dl>
<!-- example -->
<div id="def-safety-property" class="theorem definition">
<p><span class="theorem-title"><strong>Definition 6 (Safety Property) </strong></span>A LT property <span class="math inline">\(S\)</span> over AP is a <strong>safety property</strong> if for all <span class="math inline">\(\sigma \in (2^{AP})^\omega \setminus S\)</span> we can find a “bad prefix” <span class="math inline">\(\hat{\sigma}\)</span> such that no word in <span class="math inline">\(S\)</span> has prefix <span class="math inline">\(\hat{\sigma}\)</span></p>
<p><span class="math display">\[ cl(S) = S \]</span></p>
</div>
<p>Trace Equivalence != Finite Trace Equivalence <!-- TODO: note --></p>
<div id="def-liveness-property" class="theorem definition">
<p><span class="theorem-title"><strong>Definition 7 (Liveness Property) </strong></span>LT property <span class="math inline">\(L\)</span> over <span class="math inline">\(AP\)</span> is a <strong>liveness property</strong> iff.</p>
<p><span class="math display">\[pref(L) = {2^{AP}}^*\]</span></p>
</div>
<div id="def-w-regular-expression" class="theorem definition">
<p><span class="theorem-title"><strong>Definition 8 (<span class="math inline">\(\omega\)</span>-regular Expression) </strong></span>An <span class="math inline">\(\omega\)</span>-regular expression has the form:</p>
<p><span class="math display">\[G = E_1.F_1^\omega+ ... + E_n.F_n^\omega\]</span></p>
<p>where <span class="math inline">\(E_i, F_i\)</span> are regular expressions.</p>
<p>If a LT property can be defined by an <span class="math inline">\(\omega\)</span>-regular expression we call it <span class="math inline">\(\omega\)</span>-<em>regular property</em></p>
</div>
<div id="thm-trace-inclusion-lt-properties" class="theorem">
<p><span class="theorem-title"><strong>Theorem 1 </strong></span>Let <span class="math inline">\(TS, TS'\)</span> be transition systems without terminal states:</p>
<p><span class="math display">\[\begin{align}
Traces(TS) \quad &amp; \subseteq \quad Traces(TS') \\
&amp; \text{iff.} \\
TS' \models P \quad &amp; \Rightarrow \quad TS \models P
, \text{ for all LT-props } P\\
\end{align}\]</span></p>
<p>For <strong>safety property</strong> we know that:</p>
<p><span class="math display">\[\begin{align}
Traces_{fin}(TS) \quad &amp; \subseteq \quad Traces_{fin}(TS') \\
&amp; \text{iff.} \\
TS' \models P \quad &amp; \Rightarrow \quad TS \models P
, \text{ for all \textbf{safety} props } P\\
\end{align}\]</span></p>
</div>
<div id="cor-trace-equivalence" class="theorem corollary">
<p><span class="theorem-title"><strong>Corollary 1 </strong></span></p>
<p><span class="math inline">\(Traces(TS) = Traces(TS')\)</span> iff. <span class="math inline">\(TS\)</span> and <span class="math inline">\(TS'\)</span> satisfy the same LT properties and analogously<br>
<span class="math inline">\(Traces_{fin}(TS) = Traces_{fin}(TS')\)</span> iff. <span class="math inline">\(TS\)</span> and <span class="math inline">\(TS'\)</span> satisfy the same safety properties.</p>
</div>
<div id="lem-finite-image-trace" class="theorem lemma">
<p><span class="theorem-title"><strong>Lemma 1 </strong></span>If <span class="math inline">\(TS'\)</span> is image finite (ger: endlich verzweigt) we know that:</p>
<p><span class="math display">\[Traces(TS) \subseteq Traces(TS') \Leftrightarrow
  Traces_{fin}(TS) \subseteq Traces_{fin}(TS')\]</span></p>
</div>
<div id="def-synchronous-product" class="theorem definition">
<p><span class="theorem-title"><strong>Definition 9 (Synchronous Product) </strong></span>Let:</p>
<ul>
<li><span class="math inline">\(TS := (S, Act, \rightharpoonup, I, AP, L)\)</span> without terminal states</li>
<li><span class="math inline">\(A := (Q, \Sigma, \rightharpoondown, Q_0, F)\)</span> and NFA
<ul>
<li><span class="math inline">\(\Sigma = 2^{AP}\)</span> i.e.&nbsp;defines trace prefixes</li>
<li><span class="math inline">\(Q_0 \cap F = \emptyset\)</span></li>
</ul></li>
</ul>
<p>Let <span class="math inline">\(TS\)</span> be a transition system without terminal states and<br>
<span class="math inline">\(A\)</span> an NFA with <span class="math inline">\(\Sigma = 2^{AP}\)</span> and <span class="math inline">\(Q_0 \cap F = \emptyset\)</span></p>
<p>Then:</p>
<p><span class="math display">\[TS \otimes A := (S', Act, \rightarrow, I', AP', L')\]</span></p>
<ul>
<li><span class="math inline">\(S' = S \times Q\)</span></li>
<li><span class="math inline">\(AP' = Q\)</span></li>
<li><span class="math inline">\(L'( \langle s, q \rangle) = \{q\}\)</span></li>
<li><span class="math inline">\(\rightarrow\)</span> can be deduced by:</li>
</ul>
<p><span class="math display">\[\frac{s \xrightharpoonup{\alpha} \textcolor{orange}{t} \land q \xrightharpoondown{L(\textcolor{orange}{t})} p} {\langle {s}, {q} \rangle \xrightarrow{\alpha} \langle {\textcolor{orange}{t}}, {p} \rangle}\]</span></p>
<ul>
<li><span class="math inline">\(I' = \{ \langle s_0, q \rangle | s_0 \in I \land \exists q_0 \in Q_0 . q_0 \xrightharpoondown{L(s_0)} q \}\)</span></li>
</ul>
</div>
<div id="thm-verifying-regular-safety-properties" class="theorem">
<p><span class="theorem-title"><strong>Theorem 2 </strong></span>Let <span class="math inline">\(TS\)</span> be some transition system. <span class="math inline">\(E_{safe}\)</span> a safety property and <span class="math inline">\(A\)</span> an NFA that recognizes the bad prefixes of <span class="math inline">\(E_{safe}\)</span>. Then:</p>
<p><span class="math display">\[TS \models E_{safe} \Leftrightarrow TS \otimes A \text{ has no reachable accepting states}\]</span></p>
</div>
<div id="def-buechi-automaton" class="theorem definition">
<p><span class="theorem-title"><strong>Definition 10 (Büchi automaton) </strong></span>A <em>nondeterministic Büchi automaton</em> (NBA) is a tuple <span class="math inline">\((Q, \Sigma, \delta, Q_0, F)\)</span> where:</p>
<ul>
<li><span class="math inline">\(Q\)</span> is a finite set of <strong>states</strong></li>
<li><span class="math inline">\(\Sigma\)</span> is a finite <strong>alphabet</strong></li>
<li><span class="math inline">\(\delta: Q \times \Sigma \rightarrow 2^Q\)</span> a <strong>transition function</strong></li>
<li><span class="math inline">\(Q_0 \subseteq Q\)</span> a set of <strong>initial states</strong></li>
<li><span class="math inline">\(F \subseteq Q\)</span> set of <strong>accepting states</strong></li>
</ul>
<p><strong>Acceptance condition</strong>: There exists a run that <strong>infinitely often</strong> visits an accepting state.</p>
</div>
<table class="table">
<caption>NFA vs.&nbsp;NBA</caption>
<colgroup>
<col style="width: 21%">
<col style="width: 39%">
<col style="width: 39%">
</colgroup>
<thead>
<tr class="header">
<th>Property</th>
<th>NFA</th>
<th>NBA</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Recognizes:</td>
<td>regular languages</td>
<td><span class="math inline">\(\omega\)</span>-regular languages</td>
</tr>
<tr class="even">
<td>Closure <span class="math inline">\(\cup\)</span></td>
<td>union operator</td>
<td>union operator</td>
</tr>
<tr class="odd">
<td>Closure <span class="math inline">\(\cap\)</span></td>
<td>product construction</td>
<td>GNBA product</td>
</tr>
<tr class="even">
<td>Closure <span class="math inline">\(\neg\)</span></td>
<td>build DFA and complement F</td>
<td>complex procedure</td>
</tr>
<tr class="odd">
<td>Determinism</td>
<td>NFA = DFA</td>
<td>DBA <span class="math inline">\(\subsetneq\)</span> NBA</td>
</tr>
</tbody>
</table>
<!-- lecture 6 start -->
</section>
<section id="verifying-omega-regular-safety-properties" class="level2">
<h2 class="anchored" data-anchor-id="verifying-omega-regular-safety-properties">Verifying <span class="math inline">\(\omega\)</span>-regular Safety Properties</h2>
<dl>
<dt>Idea</dt>
<dd>
Define Büchi automaton <span class="math inline">\(\mathfrak{A}\)</span> for <em>bad behaviour</em> <span class="math inline">\(E\)</span>. The atomic property <span class="math inline">\(F\)</span> labels all <em>accepting</em> states of <span class="math inline">\(\mathfrak{A}\)</span>. Check if
</dd>
</dl>
<p><span class="math display">\[T \otimes \mathfrak{A} \models \text{ eventually forever } \neg F\]</span></p>
<p>Here <span class="math inline">\(\otimes\)</span> is defined like in <a href="#def-synchronous-product">Definition&nbsp;9</a>.</p>
<div id="thm-persistence-prop-check" class="theorem">
<p><span class="theorem-title"><strong>Theorem 3 (Persistence Property Check) </strong></span>Let <span class="math inline">\(P\)</span> be some <em>persistence property</em> of the form “<span class="math inline">\(\text{eventually forever } \varphi\)</span>”. Then it equivalent:</p>
<ol type="1">
<li><span class="math inline">\(\Leftrightarrow TS \models P\)</span></li>
<li><span class="math inline">\(\Leftrightarrow \exists s. (s \in \text{Reach}(TS) \land s \not \models \varphi\land s \text{ is on cycle})\)</span></li>
<li><span class="math inline">\(\Leftrightarrow \exists C. (C \text{ is reachable } \land C \text{ is a SCC} \land C \cap \{ s \in S | s \not \models \varphi\} \neq \emptyset)\)</span></li>
</ol>
<dl>
<dt>Strongly Connected Component (<a href="https://en.wikipedia.org/wiki/Strongly_connected_component">SCC</a>)</dt>
<dd>
Set of <strong>states</strong> <span class="math inline">\(C\)</span> such that for all <span class="math inline">\(x, y \in C\)</span>: <span class="math inline">\(x\)</span> is <em>reachable</em> from <span class="math inline">\(y\)</span>.
</dd>
</dl>
<section id="scc-method" class="level3">
<h3 class="anchored" data-anchor-id="scc-method">SCC Method</h3>
<ul>
<li>compute all <em>inclusion maximal</em> SCCs</li>
<li>remove unreachable SCCs</li>
<li>check for a state <span class="math inline">\(s \models \neg \varphi\)</span></li>
</ul>
<div class="callout-caution callout callout-style-default callout-captioned">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-caption-container flex-fill">
Not practical
</div>
</div>
<div class="callout-body-container callout-body">

</div>
</div>
</section>
<section id="cycle-method" class="level3">
<h3 class="anchored" data-anchor-id="cycle-method">Cycle Method</h3>
<p><strong>Naïve way:</strong> <span class="math inline">\(\Theta(|V| \cdot |E|)\)</span></p>
<ul>
<li>use <a href="https://en.wikipedia.org/wiki/Depth-first_search">DFS</a> to find states <span class="math inline">\(s \models \neg \varphi\)</span></li>
<li>use <em>second</em> DFS to check wether cycle is reachable from itself (i.e.&nbsp;belongs to cycle)</li>
</ul>
<p><strong>Imprövement:</strong> <span class="math inline">\(\Theta(|V| + |E|)\)</span></p>
<ul>
<li>use outer DFS to find states <span class="math inline">\(s \models \neg \varphi\)</span></li>
<li>use inner DFS to check wether cycle is reachable from itself <strong>while avoiding states visited in a previous inner DFS</strong>, i.e.&nbsp;maintain <strong>one</strong> <code>visited</code> set across all executions of the inner DFS.</li>
</ul>
</section>
</div>
<!-- lecture 6 end -->
</section>
<section id="linear-temporal-logic-ltl" class="level2">
<h2 class="anchored" data-anchor-id="linear-temporal-logic-ltl">Linear Temporal Logic (LTL)</h2>
<!-- macros -->
<!-- tomporal -->
<!-- modal -->
<p>For a set of atomic propositions <span class="math inline">\(AP\)</span> we give the BNF grammar for LTL:</p>
<ul>
<li><span class="math inline">\(\varphi= a \text{ for } a \in AP\)</span></li>
<li><span class="math inline">\(\varphi= \texttt{true}| \varphi\lor \varphi| \neg \varphi\)</span></li>
<li><span class="math inline">\(\varphi= \bigcirc\varphi\)</span> “next”</li>
<li><span class="math inline">\(\varphi= \varphi\textbf{U}\varphi\)</span> “until”</li>
</ul>
<p><strong>Derived Operators</strong>:</p>
<ul>
<li>the usual:<br>
<span class="math inline">\(\texttt{false}, \lor, \leftarrow, \rightarrow, \leftrightarrow, \otimes\)</span></li>
<li>modal operators:
<ul>
<li>“eventually” <span class="math inline">\(\diamond\varphi:= \texttt{true}\textbf{U}\varphi\)</span></li>
<li>“always” <span class="math inline">\(\square\varphi:= \neg \diamond\neg \varphi\)</span></li>
</ul></li>
<li>temporal operators:
<ul>
<li>“release” <span class="math inline">\(\varphi\textbf{R}\psi := \neg (\neg \varphi\textbf{U}\psi)\)</span></li>
<li>“weak until” <span class="math inline">\(\varphi\textbf{W}\psi := (\varphi\textbf{U}\psi) \lor \square\varphi\)</span></li>
<li>“strong release” <span class="math inline">\(\varphi\textbf{M}\psi := (\varphi\textbf{R}\psi) \land \diamond\varphi\)</span></li>
</ul></li>
</ul>
<p><strong>Equivalences</strong>:</p>
<p><strong>Dualities</strong>:</p>
<ul>
<li><span class="math inline">\(\neg \square\varphi\equiv \diamond\neg \varphi\)</span></li>
<li><span class="math inline">\(\neg \bigcirc\varphi\equiv \bigcirc\neg \varphi\)</span></li>
<li><span class="math inline">\(\neg (\varphi\textbf{U}\psi) \equiv \neg \varphi\textbf{R}\neg \psi\)</span></li>
<li><span class="math inline">\(\neg (\varphi\textbf{U}\psi) \equiv (\varphi\land \neg \psi) \textbf{R}(\neg \varphi\land \neg \psi)\)</span></li>
<li><span class="math inline">\(\neg (\varphi\textbf{W}\psi) \equiv \neg \varphi\textbf{M}\neg \psi\)</span></li>
<li><span class="math inline">\(\neg (\varphi\textbf{W}\psi) \equiv (\varphi\land \neg \psi) \textbf{U}(\neg \varphi\land \neg \psi)\)</span></li>
</ul>
<p><strong>Absorbtion</strong>:</p>
<ul>
<li><span class="math inline">\(\square\square\varphi\equiv \square\varphi\)</span></li>
<li><span class="math inline">\(\diamond\diamond\varphi\equiv \diamond\varphi\)</span></li>
<li><span class="math inline">\(\square\diamond\square\varphi\equiv \diamond\square\varphi\)</span></li>
<li><span class="math inline">\(\diamond\square\diamond\varphi\equiv \square\diamond\varphi\)</span></li>
<li><span class="math inline">\(\varphi\textbf{U}(\varphi\textbf{U}\psi) \equiv \varphi\textbf{U}\psi\)</span></li>
<li><span class="math inline">\((\varphi\textbf{U}\psi) \textbf{U}\psi \equiv \varphi\textbf{U}\psi\)</span></li>
</ul>
<p><strong>Distribution</strong>:</p>
<ul>
<li><span class="math inline">\(\bigcirc(\varphi\textbf{U}\psi) \equiv (\bigcirc\varphi\textbf{U}\bigcirc\psi)\)</span></li>
<li><span class="math inline">\(\diamond(\varphi\lor \psi) \equiv \diamond\varphi\lor \diamond\psi\)</span></li>
<li><span class="math inline">\(\square(\varphi\land \psi) \equiv \square\varphi\land \square\psi\)</span></li>
</ul>
<div class="callout-caution callout callout-style-default callout-captioned">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-caption-container flex-fill">
Danger
</div>
</div>
<div class="callout-body-container callout-body">
<ul>
<li><span class="math inline">\(\diamond(\varphi\land \psi) \not \equiv \diamond\varphi\land \diamond\psi\)</span></li>
<li><span class="math inline">\(\square(\varphi\lor \psi) \not \equiv \square\varphi\lor \square\psi\)</span></li>
</ul>
</div>
</div>
<p><strong>Expansion</strong>:</p>
<ul>
<li><span class="math inline">\(\diamond\varphi\equiv \varphi\lor \bigcirc\diamond\varphi\)</span></li>
<li><span class="math inline">\(\square\varphi\equiv \varphi\land \bigcirc\square\varphi\)</span></li>
<li><span class="math inline">\(\varphi\textbf{U}\psi \equiv \psi \lor (\varphi\land \bigcirc(\varphi\textbf{U}\psi))\)</span></li>
</ul>
<!-- TODO: formal semantics -->
<!-- TODO: examples -->
</section>
<section id="model-checking-of-ltl" class="level2">
<h2 class="anchored" data-anchor-id="model-checking-of-ltl">Model checking of LTL</h2>
<div id="def-gnba" class="theorem definition">
<p><span class="theorem-title"><strong>Definition 11 (Generalized Büchi Automata) </strong></span>A <em>Generalized Non-deterministic Büchi Automaton</em> (GNBA) is a tuple <span class="math inline">\((Q, \Sigma, \delta, Q_0, \mathfrak{F})\)</span> where</p>
<p><span class="math display">\[\mathfrak{F} = \{ F_1, ..., F_k \} \text{ with } F_i \subseteq Q\]</span></p>
<p>A run <span class="math inline">\(r_1r_2...\)</span> on this automaton is <strong>accepting</strong> if:</p>
<p><span class="math display">\[\forall F_j. \exists^\infty i. r_i \in F_j\]</span></p>
</div>
<div class="callout-note callout callout-style-default callout-captioned">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-caption-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<p>For NBA <span class="math inline">\(A\)</span> the NBA for <span class="math inline">\(\bar{A}\)</span> has <span class="math inline">\(c^{n^2}\)</span> states in worst case.</p>
<p>Solution: use <span class="math inline">\(A_{\neg \varphi} \equiv \bar{A}\)</span></p>
</div>
</div>
<p>expant <span class="math inline">\(\sigma = A_1A_2...\)</span> to <span class="math inline">\(B_1B_2...\)</span> where <span class="math inline">\(B_i = A_i \cup \{ \psi | \psi \models A_i, \psi \text{ subformula of } \varphi\}\)</span></p>
<dl>
<dt>Closure of LTL formula</dt>
<dd>
all subformulas and their negations
</dd>
</dl>
<div id="def-elementary-sets" class="theorem definition">
<p><span class="theorem-title"><strong>Definition 12 (Elementary sets) </strong></span>Let</p>
<ol type="1">
<li>maximaly consistent:</li>
</ol>
<ul>
<li><span class="math inline">\(\varphi\land \psi \in B \Leftrightarrow \varphi\in B \land \psi \in B\)</span></li>
<li><span class="math inline">\(\varphi\notin B \Leftrightarrow \neg \varphi\in B\)</span></li>
<li><span class="math inline">\(true \in cl(\varphi) \Rightarrow true \in B\)</span></li>
</ul>
<ol start="2" type="1">
<li>locally consistent: for <span class="math inline">\(\varphi U \psi \in cl(\sigma)\)</span></li>
</ol>
<ul>
<li><span class="math inline">\(\psi \in B \Rightarrow \varphi U \psi \in B\)</span></li>
<li><span class="math inline">\(\varphi U \psi \in B \land \psi \notin B \Rightarrow \varphi\in B\)</span></li>
</ul>
</div>
<ul>
<li><span class="math inline">\(\Sigma = 2^{AP}\)</span></li>
<li>$Q := $ elementary sets</li>
<li><span class="math inline">\(Q_0\)</span> all sets with <span class="math inline">\(\varphi\)</span></li>
<li>$:= $
<ul>
<li><span class="math inline">\(\circ \varphi\in B \Leftrightarrow \varphi\in B'\)</span></li>
<li>(expansion law) $U B (B (B U B’))</li>
</ul></li>
</ul>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    target: function(trigger) {
      return trigger.previousElementSibling;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    setTimeout(function() {
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      let href = ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const cites = ref.parentNode.getAttribute('data-cites').split(' ');
    tippyHover(ref, function() {
      var popup = window.document.createElement('div');
      cites.forEach(function(cite) {
        var citeDiv = window.document.createElement('div');
        citeDiv.classList.add('hanging-indent');
        citeDiv.classList.add('csl-entry');
        var biblioDiv = window.document.getElementById('ref-' + cite);
        if (biblioDiv) {
          citeDiv.innerHTML = biblioDiv.innerHTML;
        }
        popup.appendChild(citeDiv);
      });
      return popup.innerHTML;
    });
  }
});
</script>
</div> <!-- /content -->



</body></html>